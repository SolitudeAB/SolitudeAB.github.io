<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/12/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2024/12/31/test/</url>
    <content><![CDATA[<p>首先科普一个小知识，全角英文跟中文一样占两个字节。</p>
<p>一个字节等于一个座位，全角字符坐两个位置，半角字符坐一个位置。</p>
<p>所以，不要使用全角英文或中文作为用户名。</p>
<p><strong>为什么呢？</strong></p>
<p>使用全角字符作为用户名可能会出现这些问题：</p>
<p>1、部分软件在安装、使用时文件路径上会显示错误（如：Adobe系列）；</p>
<p>2、部分软件在使用或调试的时候出现问题（如：软件开发、软件调试）；</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/b822a3f5f562ee6ae29d4d871dd8f0043494371183822956.jpg@1192w.webp" alt="img"></p>
<p><strong>如何改正？</strong></p>
<p><strong>一、修改用户名</strong></p>
<p>1、键盘同时按下WIN+R键，输入netplwiz，点击确定。</p>
<p>2、找到要修改的用户名，点击属性，将用户名和全名都改成英文，点击确定。</p>
<p>3、关闭所有窗口，重启电脑。</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/0456aef9ebcf92ace06901e2d0f1ecad3494371183822956.jpg@1192w.webp" alt="img"></p>
<p><strong>二、修改注册表路径</strong></p>
<p>1、键盘同时按下WIN+R键，输入regedit，点击确定。</p>
<p>2、查找以下路径</p>
<p>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList</p>
<p>3、然后在子文件夹中查找右边有用户名的选项，双击选项，修改中文为英文。</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/b8a92301397badd9224af35421c075eb3494371183822956.jpg@1192w.webp" alt="img"></p>
<p><strong>三、修改用户路径</strong></p>
<p>打开此电脑，进入C盘，双击Users，把中文该为英文名，更改完成以后重启电脑。</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/1580c08b297b924802849016cd82912e3494371183822956.jpg@1192w.webp" alt="img"></p>
<p><strong>四、更改环境变量</strong></p>
<p>右键此电脑，找到属性，下拉找到关于，右边找到高级系统设置，点击环境变量，将值中的中文名改为英文。</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/cd7434ace4ae9f788a8d3a77aa8ddadf3494371183822956.jpg@1192w.webp" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/31/%E7%94%B5%E8%84%91%E7%94%A8%E6%88%B7%E5%90%8D%E8%AE%BE%E7%BD%AE%E4%BA%86%E4%B8%AD%E6%96%87%EF%BC%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<p>首先科普一个小知识，全角英文跟中文一样占两个字节。</p>
<p>一个字节等于一个座位，全角字符坐两个位置，半角字符坐一个位置。</p>
<p>所以，不要使用全角英文或中文作为用户名。</p>
<p><strong>为什么呢？</strong></p>
<p>使用全角字符作为用户名可能会出现这些问题：</p>
<p>1、部分软件在安装、使用时文件路径上会显示错误（如：Adobe系列）；</p>
<p>2、部分软件在使用或调试的时候出现问题（如：软件开发、软件调试）；</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/b822a3f5f562ee6ae29d4d871dd8f0043494371183822956.jpg" alt="img"></p>
<p><strong>如何改正？</strong></p>
<p><strong>一、修改用户名</strong></p>
<p>1、键盘同时按下WIN+R键，输入netplwiz，点击确定。</p>
<p>2、找到要修改的用户名，点击属性，将用户名和全名都改成英文，点击确定。</p>
<p>3、关闭所有窗口，重启电脑。</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/0456aef9ebcf92ace06901e2d0f1ecad3494371183822956.jpg@1192w.webp" alt="img"></p>
<p><strong>二、修改注册表路径</strong></p>
<p>1、键盘同时按下WIN+R键，输入regedit，点击确定。</p>
<p>2、查找以下路径</p>
<p>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList</p>
<p>3、然后在子文件夹中查找右边有用户名的选项，双击选项，修改中文为英文。</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/b8a92301397badd9224af35421c075eb3494371183822956.jpg@1192w.webp" alt="img"></p>
<p><strong>三、修改用户路径</strong></p>
<p>打开此电脑，进入C盘，双击Users，把中文该为英文名，更改完成以后重启电脑。</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/1580c08b297b924802849016cd82912e3494371183822956.jpg@1192w.webp" alt="img"></p>
<p><strong>四、更改环境变量</strong></p>
<p>右键此电脑，找到属性，下拉找到关于，右边找到高级系统设置，点击环境变量，将值中的中文名改为英文。</p>
<p><img src="https://i1.hdslb.com/bfs/new_dyn/cd7434ace4ae9f788a8d3a77aa8ddadf3494371183822956.jpg@1192w.webp" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/31/PTA/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="7-1-字典合并"><a href="#7-1-字典合并" class="headerlink" title="7-1 字典合并"></a>7-1 字典合并</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">// 声明处理字符串的函数</span><br><span class="line">void solve(string&amp; str);</span><br><span class="line"></span><br><span class="line">// 存储解析出的键值对</span><br><span class="line">vector&lt;pair&lt;int, string&gt;&gt; vd;</span><br><span class="line">// 存储键到值的映射</span><br><span class="line">unordered_map&lt;string, int&gt; m;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    string s1, s2; // 用于存储两行输入</span><br><span class="line">    getline(cin, s1); // 读取第一行</span><br><span class="line">    getline(cin, s2); // 读取第二行</span><br><span class="line"></span><br><span class="line">    solve(s1); // 解析第一行</span><br><span class="line">    solve(s2); // 解析第二行</span><br><span class="line"></span><br><span class="line">    // 按照 ASCII 值和字符串排序</span><br><span class="line">    sort(vd.begin(), vd.end());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;&#123;&quot;; // 输出开始的花括号</span><br><span class="line">    for (int i = 0; i &lt; vd.size(); i++) &#123;</span><br><span class="line">        string s = vd[i].second; // 获取当前元素的字符串</span><br><span class="line">        if (i &gt; 0) &#123; cout &lt;&lt; &quot;,&quot;; &#125; // 如果不是第一个元素，输出逗号</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; &quot;:&quot; &lt;&lt; m[s]; // 输出键和对应的值</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;&#125;&quot;; // 输出结束的花括号</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解析输入字符串</span><br><span class="line">void solve(string&amp; s) &#123;</span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123; // 遍历字符串中的每个字符</span><br><span class="line">        if (s[i] == &#x27;:&#x27;) &#123; // 找到键值对的分隔符 &#x27;:&#x27;</span><br><span class="line">            string str; // 用于存储键</span><br><span class="line">            int asc = 0; // 存储键的 ASCII 值</span><br><span class="line">            int sum = 0; // 存储值的总和</span><br><span class="line"></span><br><span class="line">            // 读取键值</span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                // 读取字符键</span><br><span class="line">                if (s[i - 1] == &#x27;&quot;&#x27;) &#123; // 如果键是字符串（被引号包围）</span><br><span class="line">                    str += &#x27;&quot;&#x27;; // 添加开头的引号</span><br><span class="line">                    str += s[i - 2]; // 添加字符</span><br><span class="line">                    str += &#x27;&quot;&#x27;; // 添加结尾的引号</span><br><span class="line">                    asc = static_cast&lt;int&gt;(s[i - 2]); // 获取字符的 ASCII 值</span><br><span class="line">                &#125;</span><br><span class="line">                // 读取数字键</span><br><span class="line">                else &#123;</span><br><span class="line">                    int j = i; // j 指向当前 &#x27;:&#x27; 的位置</span><br><span class="line">                    while (s[j - 1] != &#x27;,&#x27; &amp;&amp; s[j - 1] != &#x27;&#123;&#x27;) &#123; // 向前找到数字的开始</span><br><span class="line">                        str += s[j - 1]; // 逐个添加字符</span><br><span class="line">                        j--; // 向前移动</span><br><span class="line">                    &#125;</span><br><span class="line">                    reverse(str.begin(), str.end()); // 反转字符串，获取正确的数字表示</span><br><span class="line">                    asc = stoi(str); // 将字符串转换为整数</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 读取值</span><br><span class="line">                i++; // 移动到值的开始</span><br><span class="line">                while (i &lt; s.size() &amp;&amp; s[i] != &#x27;,&#x27; &amp;&amp; s[i] != &#x27;&#125;&#x27;) &#123; // 读取直到遇到分隔符</span><br><span class="line">                    if (isdigit(s[i])) &#123; // 如果当前字符是数字</span><br><span class="line">                        sum = sum * 10 + (s[i] - &#x27;0&#x27;); // 更新值</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++; // 移动到下一个字符</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 更新映射</span><br><span class="line">                if (m[str]) &#123; // 如果键已经存在</span><br><span class="line">                    m[str] += sum; // 累加值</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    vd.push_back(&#123; asc, str &#125;); // 否则，添加新的键值对</span><br><span class="line">                    m[str] = sum; // 初始化键的值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-2-这是二叉搜索树吗？"><a href="#7-2-这是二叉搜索树吗？" class="headerlink" title="7-2 这是二叉搜索树吗？"></a>7-2 这是二叉搜索树吗？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	int val;</span><br><span class="line">	node* lchild, * rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void build(node* &amp;T, int data) &#123;</span><br><span class="line">	if(T == NULL) &#123;</span><br><span class="line">		T = new node; </span><br><span class="line">		T-&gt;val = data;</span><br><span class="line">		T-&gt;lchild = T-&gt;rchild = NULL;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if (data &lt; T-&gt;val) &#123; build(T-&gt;lchild, data); &#125;</span><br><span class="line">	else &#123; build(T-&gt;rchild, data); &#125;</span><br><span class="line">&#125;</span><br><span class="line">//前序遍历二叉树</span><br><span class="line">void preorder(node* T, vector&lt;int&gt;&amp; vi) &#123;</span><br><span class="line">	if (T == NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	vi.push_back(T-&gt;val);</span><br><span class="line">	preorder(T-&gt;lchild, vi);</span><br><span class="line">	preorder(T-&gt;rchild, vi);</span><br><span class="line">&#125;</span><br><span class="line">//得到前序镜像二叉树遍历结果</span><br><span class="line">void pre_mirror(node* T, vector&lt;int&gt;&amp; vi) &#123;</span><br><span class="line">	if (T == NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	vi.push_back(T-&gt;val);</span><br><span class="line">	pre_mirror(T-&gt;rchild, vi);</span><br><span class="line">	pre_mirror(T-&gt;lchild, vi);</span><br><span class="line">&#125;</span><br><span class="line">//得到后序二叉树</span><br><span class="line">void postorder(node* T, vector&lt;int&gt;&amp; vi) &#123;</span><br><span class="line">	if (T == NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	postorder(T-&gt;lchild, vi);</span><br><span class="line">	postorder(T-&gt;rchild, vi);</span><br><span class="line">	vi.push_back(T-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">//得到后序镜像二叉树遍历结果</span><br><span class="line">void post_mirror(node* T, vector&lt;int&gt;&amp; vi) &#123;</span><br><span class="line">	if (T == NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	post_mirror(T-&gt;rchild, vi);</span><br><span class="line">	post_mirror(T-&gt;lchild, vi);</span><br><span class="line">	vi.push_back(T-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; initial, pre, pre_m, post, post_m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">	cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">	cout.tie(0);</span><br><span class="line"></span><br><span class="line">	int n, data;</span><br><span class="line">	node* T = NULL;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; data;</span><br><span class="line">		initial.push_back(data);</span><br><span class="line">		build(T, data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preorder(T, pre);</span><br><span class="line">	pre_mirror(T, pre_m);</span><br><span class="line">	postorder(T, post);</span><br><span class="line">	post_mirror(T,post_m);</span><br><span class="line"></span><br><span class="line">	if (initial == pre) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">		for (int i = 0; i &lt; post.size(); i++) &#123;</span><br><span class="line">			if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125;</span><br><span class="line">			cout &lt;&lt; post[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (initial == pre_m) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">		for (int i = 0; i &lt; post_m.size(); i++) &#123;</span><br><span class="line">			if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125;</span><br><span class="line">			cout &lt;&lt; post_m[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-是否同一棵二叉搜索树"><a href="#7-3-是否同一棵二叉搜索树" class="headerlink" title="7-3 是否同一棵二叉搜索树"></a>7-3 是否同一棵二叉搜索树</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">// 定义树节点的结构体</span><br><span class="line">typedef struct TreeNode &#123;</span><br><span class="line">    int val; // 节点的值</span><br><span class="line">    TreeNode* lchild, *rchild; // 左右子节点指针</span><br><span class="line">    int flag; // 标记节点是否被访问过</span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode* newNode(int v); // 创建新节点并初始化</span><br><span class="line">TreeNode* insert(TreeNode* T, int v); // 在树中插入新值</span><br><span class="line">TreeNode* buildTree(int N); // 根据输入构建树</span><br><span class="line">bool check(TreeNode* T, int v); // 检查值是否在树中</span><br><span class="line">bool judge(TreeNode* T, int N); // 判断给定序列是否在树中</span><br><span class="line">void freeTree(TreeNode* T); // 释放树的内存</span><br><span class="line">void reSet(TreeNode* T); // 重置树的标记</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int N, L; // N为树节点个数，L为查询序列长度</span><br><span class="line">    TreeNode* T; // 树的根节点</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; N; // 输入节点个数</span><br><span class="line">    while (N) &#123;</span><br><span class="line">        cin &gt;&gt; L; // 输入查询序列的长度</span><br><span class="line">        T = buildTree(N); // 构建树</span><br><span class="line">        for (int i = 0; i &lt; L; i++) &#123;</span><br><span class="line">            if (judge(T, N)) &#123; // 判断查询序列是否在树中</span><br><span class="line">                cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; // 存在</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; // 不存在</span><br><span class="line">            &#125;</span><br><span class="line">            reSet(T); // 重置树的标记</span><br><span class="line">        &#125;</span><br><span class="line">        freeTree(T); // 释放树的内存</span><br><span class="line">        cin &gt;&gt; N; // 输入下一个节点个数</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建新节点并初始化</span><br><span class="line">TreeNode* newNode(int v) &#123;</span><br><span class="line">    TreeNode* T = new TreeNode;</span><br><span class="line">    T-&gt;flag = 0; // 初始标记为未访问</span><br><span class="line">    T-&gt;val = v; // 设置节点值</span><br><span class="line">    T-&gt;lchild = T-&gt;rchild = NULL; // 左右子节点指针初始化为NULL</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在树中插入新值</span><br><span class="line">TreeNode* insert(TreeNode* T, int v) &#123;</span><br><span class="line">    if (!T) &#123;</span><br><span class="line">        T = newNode(v); // 如果树为空，创建新节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (v &gt; T-&gt;val) &#123;</span><br><span class="line">            T-&gt;rchild = insert(T-&gt;rchild, v); // 插入右子树</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            T-&gt;lchild = insert(T-&gt;lchild, v); // 插入左子树</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return T; // 返回树的根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据输入构建树</span><br><span class="line">TreeNode* buildTree(int N) &#123;</span><br><span class="line">    TreeNode* T;</span><br><span class="line">    int v;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; v; // 读入第一个值</span><br><span class="line">    T = newNode(v); // 创建根节点</span><br><span class="line">    for (int i = 1; i &lt; N; i++) &#123; // 读入剩余值并插入树中</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">        T = insert(T, v);</span><br><span class="line">    &#125;</span><br><span class="line">    return T; // 返回树的根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查值是否在树中</span><br><span class="line">bool check(TreeNode* T, int v) &#123;</span><br><span class="line">    if (T-&gt;flag) &#123; // 如果节点已经被访问过</span><br><span class="line">        if (v &lt; T-&gt;val) &#123; </span><br><span class="line">            return check(T-&gt;lchild, v); // 检查左子树</span><br><span class="line">        &#125; else if (v &gt; T-&gt;val) &#123;</span><br><span class="line">            return check(T-&gt;rchild, v); // 检查右子树</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false; // 值已存在，不允许重复访问</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // 如果节点未被访问</span><br><span class="line">        if (v == T-&gt;val) &#123;</span><br><span class="line">            T-&gt;flag = 1; // 标记为已访问</span><br><span class="line">            return true; // 找到值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false; // 值不匹配</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断给定序列是否在树中</span><br><span class="line">bool judge(TreeNode* T, int N) &#123;</span><br><span class="line">    int v, flag = 0; // flag用于标记序列是否存在</span><br><span class="line">    cin &gt;&gt; v; // 读入第一个值</span><br><span class="line">    if (v == T-&gt;val) &#123;</span><br><span class="line">        T-&gt;flag = 1; // 如果匹配，标记为已访问</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        flag = 1; // 不匹配，设置标志</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; N; i++) &#123; // 继续检查剩余值</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">        if ((!flag) &amp;&amp; (!check(T, v))) &#123; // 如果尚未发现不匹配并且当前值不在树中</span><br><span class="line">            flag = 1; // 设置标志为不匹配</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag ? false : true; // 返回是否完全匹配</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放树的内存</span><br><span class="line">void freeTree(TreeNode* T) &#123;</span><br><span class="line">    if (T-&gt;lchild) &#123; freeTree(T-&gt;lchild); &#125; // 递归释放左子树</span><br><span class="line">    if (T-&gt;rchild) &#123; freeTree(T-&gt;rchild); &#125; // 递归释放右子树</span><br><span class="line">    free(T); // 释放当前节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重置树的标记</span><br><span class="line">void reSet(TreeNode* T) &#123;</span><br><span class="line">    if (T-&gt;lchild) &#123; reSet(T-&gt;lchild); &#125; // 递归重置左子树</span><br><span class="line">    if (T-&gt;rchild) &#123; reSet(T-&gt;rchild); &#125; // 递归重置右子树</span><br><span class="line">    T-&gt;flag = 0; // 重置当前节点标记</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/31/PTA/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="7-1-根据后序和中序遍历输出前序遍历"><a href="#7-1-根据后序和中序遍历输出前序遍历" class="headerlink" title="7-1 根据后序和中序遍历输出前序遍历"></a>7-1 根据后序和中序遍历输出前序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode* lchild;</span><br><span class="line">	TreeNode* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TreeNode* T;</span><br><span class="line">	<span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span>* inorder = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	<span class="type">int</span>* postorder = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; postorder[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; inorder[i];</span><br><span class="line">	&#125;</span><br><span class="line">    T = <span class="built_in">buildTree</span>(inorder, postorder, n);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Preorder:&quot;</span>;</span><br><span class="line">	<span class="built_in">preorderTraversal</span>(T);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	TreeNode* T;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!n) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">	T-&gt;val = postorder[n - <span class="number">1</span>];</span><br><span class="line">	T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inorder[i] == postorder[n - <span class="number">1</span>]) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	T-&gt;lchild = <span class="built_in">buildTree</span>(inorder, postorder, i);</span><br><span class="line">	T-&gt;rchild = <span class="built_in">buildTree</span>(inorder + i + <span class="number">1</span>, postorder + i, n - i - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; T-&gt;val;</span><br><span class="line">	<span class="built_in">preorderTraversal</span>(T-&gt;lchild);</span><br><span class="line">	<span class="built_in">preorderTraversal</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-完全二叉树的层序遍历"><a href="#7-2-完全二叉树的层序遍历" class="headerlink" title="7-2 完全二叉树的层序遍历"></a>7-2 完全二叉树的层序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>* tree, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> tree[maxn + <span class="number">1</span>];</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">buildTree</span>(<span class="number">1</span>,tree, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123; cout &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">		cout &lt;&lt; tree[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>*tree, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; n) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="built_in">buildTree</span>(<span class="number">2</span> * i, tree, n);</span><br><span class="line">	<span class="built_in">buildTree</span>(<span class="number">2</span> * i + <span class="number">1</span>, tree, n);</span><br><span class="line">	cin &gt;&gt; tree[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-3-树的同构"><a href="#7-3-树的同构" class="headerlink" title="7-3 树的同构"></a>7-3 树的同构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="type">int</span> lchild;</span><br><span class="line">	<span class="type">int</span> rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">buildTree</span><span class="params">(TreeNode* T)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOmorphic</span><span class="params">(<span class="type">int</span> r1, <span class="type">int</span> r2)</span></span>;</span><br><span class="line"></span><br><span class="line">TreeNode tree1[maxn], tree2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> root1, root2;</span><br><span class="line">	root1 = <span class="built_in">buildTree</span>(tree1);</span><br><span class="line">	root2 = <span class="built_in">buildTree</span>(tree2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isOmorphic</span>(root1, root2))&#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉树，返回树根，空树树根为-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">buildTree</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, check[maxn];</span><br><span class="line">	<span class="type">char</span> cl, cr;</span><br><span class="line">	<span class="type">int</span> root, i;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123; check[i] = <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; T[i].val &gt;&gt; cl &gt;&gt; cr;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (cl != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				T[i].lchild = cl - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				check[T[i].lchild] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; T[i].lchild = <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (cr != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				T[i].rchild = cr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				check[T[i].rchild] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; T[i].rchild = <span class="number">-1</span>; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回根节点</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root = i;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOmorphic</span><span class="params">(<span class="type">int</span> r1, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r1 == <span class="number">-1</span> &amp;&amp; r2 == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r1 == <span class="number">-1</span> &amp;&amp; r2 != <span class="number">-1</span>) || (r1 != <span class="number">-1</span> &amp;&amp; r2 == <span class="number">-1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tree1[r1].val != tree2[r2].val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isOmorphic</span>(tree1[r1].lchild, tree2[r2].lchild) &amp;&amp; <span class="built_in">isOmorphic</span>(tree1[r1].rchild, tree2[r2].rchild)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOmorphic</span>(tree1[r1].lchild, tree2[r2].rchild) &amp;&amp; <span class="built_in">isOmorphic</span>(tree1[r1].rchild, tree2[r2].lchild)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的结构"><a href="#二叉搜索树的结构" class="headerlink" title="二叉搜索树的结构"></a>二叉搜索树的结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> T, n, m; <span class="comment">// 定义变量T（测试用例数），n（节点数），m（查询数）</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, lchild, rchild;</span><br><span class="line">	<span class="type">int</span> flor;<span class="comment">// 节点的层数（深度）</span></span><br><span class="line">	<span class="type">int</span> father;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode node[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索插入节点的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; node[u].x) &#123;</span><br><span class="line">		<span class="comment">// 如果x小于当前节点u的值，那么在u的左子树中</span></span><br><span class="line">		<span class="keyword">if</span> (!node[u].lchild) &#123;<span class="comment">//u没有左儿子，就让x作为左儿子</span></span><br><span class="line">			cnt++;</span><br><span class="line">			node[u].lchild = cnt;</span><br><span class="line">			node[cnt].x = x;</span><br><span class="line">			node[cnt].father = u;</span><br><span class="line">			node[cnt].flor = node[u].flor + <span class="number">1</span>;</span><br><span class="line">			mp[x] = cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//有左儿子就递归到左儿子</span></span><br><span class="line">			<span class="built_in">dfs</span>(x, node[u].lchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// x在u的右子树中</span></span><br><span class="line">		<span class="keyword">if</span> (!node[u].rchild) &#123;<span class="comment">//u没有y右儿子，就让x作为左儿子</span></span><br><span class="line">			cnt++;</span><br><span class="line">			node[u].rchild = cnt;</span><br><span class="line">			node[cnt].x = x;</span><br><span class="line">			node[cnt].father = u;</span><br><span class="line">			node[cnt].flor = node[u].flor + <span class="number">1</span>;</span><br><span class="line">			mp[x] = cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//有左儿子就递归到左儿子</span></span><br><span class="line">			<span class="built_in">dfs</span>(x, node[u].rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x; cin &gt;&gt; x;<span class="comment">//先确认根节点</span></span><br><span class="line">	node[<span class="number">1</span>].x = x;</span><br><span class="line">	node[<span class="number">1</span>].flor = <span class="number">1</span>;</span><br><span class="line">	mp[x] = <span class="number">1</span>;<span class="comment">//更新映射，将根节点值映射到索引1</span></span><br><span class="line">	cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从第二个结点开始插入</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="built_in">dfs</span>(x, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="built_in">getline</span>(cin, s); <span class="comment">//读取剩余行（防止读取到空行）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(cin, s); <span class="comment">// 读取查询语句</span></span><br><span class="line">		<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;root&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d is the root&quot;</span>, &amp;x);<span class="comment">// 从查询中解析出x</span></span><br><span class="line">			<span class="keyword">if</span> (mp[x] == <span class="number">1</span>) &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;siblings&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d and %d are siblings&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node[x].father != node[y].father) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;parent&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d is the parent of %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node[y].father == x) &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;left&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d is the left child of %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(node[y].lchild == x)&#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;right&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d is the right child of %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node[y].rchild == x) &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;level&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d and %d are on the same level&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node[x].flor == node[y].flor) &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>旅游规划</title>
    <url>/2024/12/31/PTA/%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="7-1-旅游规划"><a href="#7-1-旅游规划" class="headerlink" title="7-1 旅游规划"></a>7-1 旅游规划</h3><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p>
<p>输入格式:<br>输入说明：输入数据的第 1 行给出 4 个正整数 n、m、s、d，其中 n（2≤n≤500）是城市的个数，顺便假设城市的编号为 0~(n−1)；m 是高速公路的条数；s 是出发地的城市编号；d 是目的地的城市编号。随后的 m 行中，每行给出一条高速公路的信息，分别是：城市 1、城市 2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过 500。输入保证解的存在。</p>
<p>输出格式:<br>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p>
<p>输入样例:<br>4 5 0 3<br>0 1 1 20<br>1 3 2 30<br>0 3 4 10<br>0 2 2 20<br>2 3 1 20<br>输出样例:<br>3 40<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">// 定义图中的边结构体，包含目标城市（to）、路径长度（length）和费用（cost）</span><br><span class="line">typedef struct Edge&#123;</span><br><span class="line">    int to;     // 目标城市</span><br><span class="line">    int length; // 从当前城市到目标城市的路径长度</span><br><span class="line">    int cost;   // 从当前城市到目标城市的费用</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义城市状态结构体，包含城市编号、路径长度（dist）和费用（fee）</span><br><span class="line">// 重载了 &gt; 运算符，使得优先队列能根据路径长度和费用优先排序</span><br><span class="line">typedef struct State&#123;</span><br><span class="line">    int city;  // 当前城市</span><br><span class="line">    int dist;  // 从起点到当前城市的路径长度</span><br><span class="line">    int fee;   // 从起点到当前城市的总费用</span><br><span class="line">    </span><br><span class="line">    // 重载大于运算符，首先按照路径长度升序排序，如果路径长度相同则按费用升序排序</span><br><span class="line">    bool operator&gt;(const State&amp; other) const &#123;</span><br><span class="line">        if (dist == other.dist) &#123;</span><br><span class="line">            return fee &gt; other.fee;  // 如果路径长度相同，选择费用较小的路径</span><br><span class="line">        &#125;</span><br><span class="line">        return dist &gt; other.dist;  // 否则选择路径长度较小的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int n, m, s, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;  // 输入城市数 n，道路数 m，起点 s 和终点 d</span><br><span class="line">    </span><br><span class="line">    // 使用邻接表表示图，保存每条边的信息，graph[i] 存储与城市 i 相关的所有边</span><br><span class="line">    vector&lt; vector&lt;Edge&gt; &gt; graph(n);</span><br><span class="line"></span><br><span class="line">    // 输入所有的边信息，构建图</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int u, v, length, cost;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; length &gt;&gt; cost;</span><br><span class="line">        // 无向图，双向保存每条边</span><br><span class="line">        graph[u].push_back(&#123;v, length, cost&#125;);</span><br><span class="line">        graph[v].push_back(&#123;u, length, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化 Dijkstra 算法所需的数据结构</span><br><span class="line">    vector&lt;int&gt; dist(n, INF); // dist[i] 存储从起点到城市 i 的最短路径长度</span><br><span class="line">    vector&lt;int&gt; fee(n, INF);  // fee[i] 存储从起点到城市 i 的最小费用</span><br><span class="line"></span><br><span class="line">    dist[s] = 0;  // 起点到起点的路径长度是 0</span><br><span class="line">    fee[s] = 0;   // 起点到起点的费用是 0</span><br><span class="line"></span><br><span class="line">    // 优先队列，用于选择当前最优的城市，按照 (路径长度, 费用) 升序排序</span><br><span class="line">    priority_queue&lt;State, vector&lt;State&gt;, greater&lt;State&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123;s, 0, 0&#125;);  // 将起点城市推入队列，初始路径长度和费用都是 0</span><br><span class="line"></span><br><span class="line">    // Dijkstra 算法主体部分</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        State current = pq.top();  // 获取队列中的当前最优城市</span><br><span class="line">        pq.pop();  // 从队列中移除当前城市</span><br><span class="line"></span><br><span class="line">        int u = current.city;  // 当前城市编号</span><br><span class="line"></span><br><span class="line">        // 如果当前城市的路径长度大于已经记录的最短路径长度，或者路径长度相同但费用较大，则跳过</span><br><span class="line">        if (current.dist &gt; dist[u] || (current.dist == dist[u] &amp;&amp; current.fee &gt; fee[u])) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历与当前城市相邻的所有城市</span><br><span class="line">        for (int i = 0; i &lt; graph[u].size(); i++) &#123;</span><br><span class="line">            const Edge&amp; edge = graph[u][i];  // 获取当前边的信息</span><br><span class="line"></span><br><span class="line">            int v = edge.to;              // 目标城市编号</span><br><span class="line">            int newDist = dist[u] + edge.length;  // 通过当前城市到达目标城市的新路径长度</span><br><span class="line">            int newFee = fee[u] + edge.cost;     // 通过当前城市到达目标城市的新费用</span><br><span class="line"></span><br><span class="line">            // 如果新路径长度比原路径长度短，或者路径长度相同但新费用较低，则更新路径信息</span><br><span class="line">            if (newDist &lt; dist[v] || (newDist == dist[v] &amp;&amp; newFee &lt; fee[v])) &#123;</span><br><span class="line">                dist[v] = newDist;  // 更新最短路径长度</span><br><span class="line">                fee[v] = newFee;    // 更新最小费用</span><br><span class="line">                pq.push(&#123;v, newDist, newFee&#125;);  // 将新的城市状态加入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出从起点到终点的最短路径长度和最小费用</span><br><span class="line">    cout &lt;&lt; dist[d] &lt;&lt; &quot; &quot; &lt;&lt; fee[d] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-最短路径-Dijkstra"><a href="#7-2-最短路径-Dijkstra" class="headerlink" title="7-2 最短路径-Dijkstra"></a>7-2 最短路径-Dijkstra</h3><p>城市的道路四通八达，我们经常需要查找从某地出发到其他地方的路径，当然我们希望能最快到达。现得到去每个地方需要花费的时间，现请你编写程序，计算从特定地点出发到所有城市之间的最短时间。</p>
<p>输入格式:<br>输入的第一行给出城市数目N (1≤N≤10)和道路数目M和1（表示有向图）或0（表示无向图）；</p>
<p>接下来的M行对应每个城市间来往所需时间，每行给出3个正整数，分别是两个城市的编号（从1编号到N）和来往两城市间所需时间。最后一行给出一个编号，表示从此编号地点出发。</p>
<p>输出格式:<br>输出从特定地点出发到达所有城市（按编号1-编号N顺序输出）的距离（用编号1-&gt;编号**: 表示 ），如果无路，请输出no path。每个城市占一行。</p>
<p>输入样例:<br>5 5 1<br>1 2 2<br>1 4 8<br>2 3 16<br>4 3 6<br>5 3 3<br>1<br>输出样例:<br>1-&gt;1:0<br>1-&gt;2:2<br>1-&gt;3:14<br>1-&gt;4:8<br>1-&gt;5:no path<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">// 定义结构体 Edge，表示图中的一条边，包含目标城市 city 和边的权重 time</span><br><span class="line">typedef struct Edge &#123;</span><br><span class="line">    int city, time;</span><br><span class="line">    // 重载大于运算符，使优先队列能够按时间升序排列</span><br><span class="line">    bool operator&gt;(const Edge&amp; e) const &#123;</span><br><span class="line">        return time &gt; e.time;  // 按照时间升序排列</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int N, M, flag;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; flag; // 输入城市数量 N, 道路数量 M 和图的类型标志 flag</span><br><span class="line"></span><br><span class="line">    // 邻接表存储图，adj[i] 代表与城市 i 相连的所有城市及相应的时间</span><br><span class="line">    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(N + 1);</span><br><span class="line"></span><br><span class="line">    // 输入所有的道路信息，构建图</span><br><span class="line">    for (int i = 0; i &lt; M; i++) &#123;</span><br><span class="line">        int u, v, time;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; time;  // 输入一条道路信息，城市 u 到城市 v 的时间为 time</span><br><span class="line">        adj[u].push_back(&#123; v, time &#125;); // 在城市 u 的邻接表中加入到城市 v 的边</span><br><span class="line">        if (!flag) &#123; // 如果是无向图，则需要将反向的道路添加进去</span><br><span class="line">            adj[v].push_back(&#123; u, time &#125;); // 在城市 v 的邻接表中加入到城市 u 的边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int start;</span><br><span class="line">    cin &gt;&gt; start; // 输入起始城市 start</span><br><span class="line"></span><br><span class="line">    // 初始化距离数组 dist，表示从起点到各个城市的最短时间，初始值为无穷大</span><br><span class="line">    vector&lt;int&gt; dist(N + 1, INF);</span><br><span class="line">    dist[start] = 0; // 起点到起点的时间是 0</span><br><span class="line"></span><br><span class="line">    // 优先队列，用来实现 Dijkstra 算法的贪心选择</span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123; start, 0 &#125;); // 将起点加入优先队列</span><br><span class="line"></span><br><span class="line">    // Dijkstra 算法主体部分</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        int u = pq.top().city; // 当前城市 u</span><br><span class="line">        int d = pq.top().time; // 当前城市 u 的最短时间</span><br><span class="line">        pq.pop();</span><br><span class="line"></span><br><span class="line">        // 如果当前时间已经大于之前记录的最短时间，说明这是一个过时的队列元素，可以跳过</span><br><span class="line">        if (d &gt; dist[u]) &#123; continue; &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历所有与当前城市 u 相邻的城市 v</span><br><span class="line">        for (int i = 0; i &lt; adj[u].size(); i++) &#123;</span><br><span class="line">            int v = adj[u][i].first; // 相邻城市 v</span><br><span class="line">            int time = adj[u][i].second; // 当前道路的时间</span><br><span class="line"></span><br><span class="line">            // 如果通过 u 这个城市到达 v 的时间更短，则更新 v 的最短时间</span><br><span class="line">            if (dist[u] + time &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + time;</span><br><span class="line">                pq.push(&#123; v, dist[v] &#125;); // 将更新后的城市 v 加入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出从起点到所有城市的最短时间</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        if (dist[i] == INF) &#123; // 如果某个城市不可达</span><br><span class="line">            cout &lt;&lt; start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; i &lt;&lt; &quot;:no path&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123; // 否则输出最短时间</span><br><span class="line">            cout &lt;&lt; start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="7-3-图深度优先遍历"><a href="#7-3-图深度优先遍历" class="headerlink" title="7-3 图深度优先遍历"></a>7-3 图深度优先遍历</h3><p>编写程序对给定的有向图（不一定连通）进行深度优先遍历，图中包含n个顶点，编号为0至n-1。本题限定在深度优先遍历过程中，如果同时出现多个待访问的顶点，则优先选择编号最小的一个进行访问，以顶点0为遍历起点。</p>
<p>输入格式:<br>输入第一行为两个整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过50。接下来e行表示每条边的信息，每行为两个整数a、b，表示该边的端点编号，但各边并非按端点编号顺序排列。</p>
<p>输出格式:<br>输出为一行整数，每个整数后一个空格，即该有向图的深度优先遍历结点序列。</p>
<p>输入样例1:<br>3 3<br>0 1<br>1 2<br>0 2<br>输出样例1:<br>0 1 2<br>输入样例2:<br>4 4<br>0 2<br>0 1<br>1 2<br>3 0<br>输出样例2:<br>0 1 2 3<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，通常用来表示不可达或未初始化的值。</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; adj; // 邻接表，用来存储图的边。每个元素 adj[i] 存储与顶点 i 相邻的所有顶点。</span><br><span class="line">vector&lt;bool&gt; vis; // 用于标记每个顶点是否已被访问。</span><br><span class="line">vector&lt;int&gt; ans; // 存储DFS遍历的结果（遍历顺序）。</span><br><span class="line">int n, m; // n为顶点数，m为边数。</span><br><span class="line"></span><br><span class="line">// 深度优先遍历函数</span><br><span class="line">void dfs(int x) &#123;</span><br><span class="line">    ans.push_back(x);   // 访问当前节点，将其添加到答案列表</span><br><span class="line">    vis[x] = true;      // 标记当前节点为已访问</span><br><span class="line">    // 遍历当前节点的所有邻接节点</span><br><span class="line">    for (auto v : adj[x]) &#123;</span><br><span class="line">        if (!vis[v]) &#123;   // 如果该邻接节点未被访问</span><br><span class="line">            dfs(v);      // 递归访问该邻接节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭C++标准输入输出流的同步，提升性能。</span><br><span class="line">    cin.tie(0); // 解绑cin和cout，避免在输入时强制刷新输出，进一步提升性能。</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入图的顶点数 n 和边数 m。</span><br><span class="line">    adj.assign(n, &#123;&#125;); // 初始化邻接表，大小为n，每个元素是一个空的vector&lt;int&gt;。</span><br><span class="line">    vis.assign(n, false); // 初始化vis数组，标记所有顶点未访问。</span><br><span class="line"></span><br><span class="line">    // 读取每条边并更新邻接表</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; // 输入边 (u, v)，表示有一条从u到v的有向边。</span><br><span class="line">        adj[u].push_back(v); // 将v加入到u的邻接表中。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对每个顶点的邻接列表进行排序，确保深度优先遍历时访问编号最小的邻接点。</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        sort(adj[i].begin(), adj[i].end()); // 对邻接表中的每个列表进行排序。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历所有顶点，若某个顶点未被访问过，则从该顶点开始进行深度优先遍历。</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (!vis[i]) &#123; </span><br><span class="line">            dfs(i); // 从顶点i开始DFS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出DFS的遍历顺序。</span><br><span class="line">    for (auto x : ans) &#123; </span><br><span class="line">        cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 输出每个节点的遍历顺序，节点之间以空格分隔。</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; // 输出换行。</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="7-4-图的先广搜索"><a href="#7-4-图的先广搜索" class="headerlink" title="7-4 图的先广搜索"></a>7-4 图的先广搜索</h3><p>输出无向图的给定起点的先广序列。</p>
<p>输入格式:<br>输入第一行给出三个正整数，分别表示无向图的节点数N（1&lt;N≤10）、边数M（≤50）和探索起始节点编号S（节点从1到N编号）。</p>
<p>随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号。</p>
<p>输出格式:<br>输出从S开始的无向图的先广搜索序列（用编号表示每个节点），用一个空格隔开，最后也有一个空格；如果为非连通图，再在结尾处另起一行输出一个0，表示此图非连通。</p>
<p>由于广度优先遍历的节点序列是不唯一的，为了使得输出具有唯一的结果，我们约定以表头插入法构造邻接表。</p>
<p>输入样例:<br>6 8 2<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>6 4<br>3 6<br>1 5<br>输出样例:<br>2 3 1 6 4 5<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define fastio  ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line">const int N = 15;</span><br><span class="line">const int M = 55;</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to, nxt;</span><br><span class="line">&#125;edges[M&lt;&lt;1];</span><br><span class="line">int n, m, s, cnt, head[N];</span><br><span class="line">bool vis[N];</span><br><span class="line"></span><br><span class="line">void addEdge(int u, int v)&#123;</span><br><span class="line">    edges[++cnt] = Edge(&#123;v, head[u]&#125;);</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    fastio;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        addEdge(u, v);</span><br><span class="line">        addEdge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    que.push(s);</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        int x = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        ans.push_back(x);</span><br><span class="line">        for (int i = head[x]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            int to = edges[i].to;</span><br><span class="line">            if (!vis[to]) &#123;</span><br><span class="line">                vis[to] = true;</span><br><span class="line">                que.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto x : ans) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    if (ans.size() != n) &#123; cout &lt;&lt; 0; &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/31/PTA/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？"><a href="#已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？" class="headerlink" title="已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？"></a>已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？</h2><p>对一棵二叉树进行遍历，我们可以采取3中顺序进行遍历，分别是前序遍历、中序遍历和后序遍历。这三种方式是以访问父节点的顺序来进行命名的。假设父节点是N，左节点是L，右节点是R，那么对应的访问遍历顺序如下：</p>
<p>前序遍历    N－&gt;L－&gt;R<br>中序遍历    L－&gt;N－&gt;R<br>后序遍历    L－&gt;R－&gt;N</p>
<p>所以，对于以下这棵树，三种遍历方式的结果是：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1d5be45e572fa0202cdd7b2dd73afb1.png" alt="img"></p>
<ul>
<li>前序遍历    ABCDEF</li>
<li>中序遍历    CBDAEF</li>
<li>后序遍历    CDBFEA</li>
</ul>
<h2 id="已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历"><a href="#已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历" class="headerlink" title="已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历"></a>已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历</h2><p>+++</p>
<p>其实，只要知道其中任意两种遍历的顺序，我们就可以推断出剩下的一种遍历方式的顺序，这里我们只是以：知道前序遍历和中序遍历，推断后序遍历作为例子，其他组合方式原理是一样的。要完成这个任务，我们首先要利用以下几个特性：</p>
<ul>
<li><p>特性A，对于前序遍历，第一个肯定是根节点；</p>
</li>
<li><p>特性B，对于后序遍历，最后一个肯定是根节点；</p>
</li>
<li><p>特性C，利用前序或后序遍历，确定根节点，在中序遍历中，根节点的两边就可以分出左子树和右子树；</p>
</li>
<li><p>特性D，对左子树和右子树分别做前面3点的分析和拆分，相当于做递归，我们就可以重建出完整的二叉树；</p>
</li>
</ul>
<p>我们以一个例子做一下这个过程，假设：</p>
<ul>
<li>前序遍历的顺序是: CABGHEDF</li>
<li>中序遍历的顺序是: GBHACDEF</li>
</ul>
<p>第一步，我们根据特性A，可以得知根节点是C，然后，根据特性C，我们知道左子树是：GHBA，右子树是：DEF。</p>
<pre><code>                     C
                  /     \
                GBHA    DEF
</code></pre><p>第二步，取出左子树，左子树的前序遍历是：ABGH，中序遍历是：GBHA，根据特性A和C，得出左子树的父节点是A，并且A没有右子树。</p>
<pre><code>                     C
                   /   \
                 A      DEF
                /
              GBH
</code></pre><p>第三步，使用同样的方法，前序是BGH，中序是GBH，得出父节点是B，G和H分别是左右节点。</p>
<pre><code>                  C
                /   \
               A     DEF
              /
             B
           /   \
         G       H
</code></pre><p>第四步，回到右子树，它的前序是EDF，中序是DEF，依然根据特性A和C，得出父节点是E，左右节点是D和F。</p>
<pre><code>                    C
                  /   \
                 A     E
                /     /  \
               B     D    F
             /  \
            G    H
</code></pre><p>到此，我们得到了这棵完整的二叉树，因此，它的后序遍历就是：GHBADFEC。</p>
<p>因此我们按照上面的思路，采用递归的方法建树即可完成，下面给出代码，并有例题，有兴趣者可以去试试！</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/31/PTA/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="7-1-小明的账单"><a href="#7-1-小明的账单" class="headerlink" title="7-1 小明的账单"></a>7-1 小明的账单</h3><p>Background<br>Special for beginners, ^_^</p>
<p>Description<br>小明在一次聚会中，不慎遗失了自己的钱包，在接下来的日子，面对小明的将是一系列的补卡手续和堆积的账单。。。</p>
<p>在小明的百般恳求下，老板最终同意延缓账单的支付时间。可老板又提出，必须从目前还没有支付的所有账单中选出面额最大和最小的两张，并把他们付清。还没有支付的账单会被保留到下一天。</p>
<p>请你帮他计算出支付的顺序。</p>
<p>Format<br>Input<br>第 1 行：一个正整数 N(N≤15,000)，表示小明补办银联卡总共的天数。</p>
<p>第 2 行到第 N+1 行：每一行描述一天中收到的帐单。先是一个非负整数 M≤100，表示当天收到的账单数，后跟 M 个正整数（都小于 1,000,000,000），表示每张帐单的面额。</p>
<p>输入数据保证每天都可以支付两张帐单。</p>
<p>Output<br>输出共 N 行，每行两个用空格分隔的整数，分别表示当天支付的面额最小和最大的支票的面额。</p>
<p>Samples<br>样例输入1<br>4<br>3 3 6 5<br>2 8 2<br>3 7 1 7<br>0<br>样例输出1<br>3 6<br>2 8<br>1 7<br>5 7<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int id=0;</span><br><span class="line">bool vis[3000005];//账单是否已还清</span><br><span class="line">struct node &#123;//账单</span><br><span class="line">    int id;//账单编号</span><br><span class="line">    int num;//账单金额</span><br><span class="line">&#125;;</span><br><span class="line">struct big&#123;//大根堆比较仿函数</span><br><span class="line">    bool operator() (const node x,const node y)&#123;</span><br><span class="line">        return x.num&lt;y.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct samll&#123;//小根堆比较仿函数</span><br><span class="line">    bool operator() (const node x,const node y)&#123;</span><br><span class="line">        return x.num&gt;y.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;node,vector&lt;node&gt;,big&gt; qd;//大根堆</span><br><span class="line">priority_queue &lt;node,vector&lt;node&gt;,samll&gt; qx;//小根堆</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i=1;i&lt;=n;i++)&#123;//n天</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)&#123;//每天m个账单</span><br><span class="line">            int x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            id++;//编号</span><br><span class="line">            node t;</span><br><span class="line">            t.id=id;</span><br><span class="line">            t.num=x;</span><br><span class="line">            qd.push(t);//大根堆入堆</span><br><span class="line">            qx.push(t);//小根堆入堆</span><br><span class="line">        &#125;</span><br><span class="line">        while(vis[qx.top().id]==true)&#123;//把小根堆中付过的账单剔除</span><br><span class="line">            qx.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while(vis[qd.top().id]==true)&#123;//把大根堆中付过的账单剔除</span><br><span class="line">            qd.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;qx.top().num&lt;&lt;&quot; &quot;&lt;&lt;qd.top().num&lt;&lt;&quot;\n&quot;;//输出当前最小账单和最大账单</span><br><span class="line">        vis[qx.top().id]=true;//标记当前小根堆账单已付</span><br><span class="line">        vis[qd.top().id]=true;//标记当前大根堆账单已付</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-Windows消息队列"><a href="#7-2-Windows消息队列" class="headerlink" title="7-2 Windows消息队列"></a>7-2 Windows消息队列</h3><p>消息队列是 Windows 系统的基础。对于每个进程，系统维护一个消息队列。如果在进程中有特定事件发生，如点击鼠标、文字改变等，系统将把这个消息连同表示此消息优先级高低的正整数（称为优先级值）加到队列当中。同时，如果队列不是空的，这一进程循环地从队列中按照优先级获取消息。请注意优先级值低意味着优先级高。请编辑程序模拟消息队列，将消息加到队列中以及从队列中获取消息。</p>
<p>输入格式:<br>输入第 1 行给出正整数 n（≤10<br>5<br> ），随后 n 行，每行给出一个指令——GET 或 PUT，分别表示从队列中取出消息或将消息添加到队列中。如果指令是 PUT，后面就有一个消息名称、以及一个正整数表示消息的优先级，此数越小表示优先级越高。消息名称是长度不超过 10 个字符且不含空格的字符串；题目保证队列中消息的优先级无重复，且输入至少有一个 GET。</p>
<p>输出格式:<br>对于每个 GET 指令，在一行中输出消息队列中优先级最高的消息的名称和参数。如果消息队列中没有消息，输出 EMPTY QUEUE!。对于 PUT 指令则没有输出。</p>
<p>输入样例:<br>9<br>PUT msg1 5<br>PUT msg2 4<br>GET<br>PUT msg3 2<br>PUT msg4 4<br>GET<br>GET<br>GET<br>GET<br>输出样例:<br>msg2<br>msg3<br>msg4<br>msg1<br>EMPTY QUEUE!<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	char message[11];</span><br><span class="line">	int rank;</span><br><span class="line">	friend bool operator&lt;(node a, node b) &#123;</span><br><span class="line">		return a.rank &gt; b.rank;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;//有序队列，按数字进行从大到小排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	string op;</span><br><span class="line">	node p;</span><br><span class="line">	int n;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		if (op[0] == &#x27;P&#x27;) &#123;</span><br><span class="line">			cin &gt;&gt; p.message &gt;&gt; p.rank;</span><br><span class="line">			q.push(p);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(op[0] == &#x27;G&#x27;) &#123;</span><br><span class="line">			if (!q.empty()) &#123;</span><br><span class="line">				cout &lt;&lt; q.top().message &lt;&lt; endl;</span><br><span class="line">				q.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;EMPTY QUEUE!&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/31/PTA/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="7-1-选择法排序"><a href="#7-1-选择法排序" class="headerlink" title="7-1 选择法排序"></a>7-1 选择法排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-冒泡法排序"><a href="#7-2-冒泡法排序" class="headerlink" title="7-2 冒泡法排序"></a>7-2 冒泡法排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> K, count = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j<span class="number">+1</span>];</span><br><span class="line">                arr[j<span class="number">+1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == K) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-两个有序链表序列的合并"><a href="#7-3-两个有序链表序列的合并" class="headerlink" title="7-3 两个有序链表序列的合并"></a>7-3 两个有序链表序列的合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, x;</span><br><span class="line">    <span class="built_in">memset</span>(a, INF, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123; flag++; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; a[i++] = x; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a, a + i);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index) &#123; cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[j]; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            cout &lt;&lt; a[j]; </span><br><span class="line">            index = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!index) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-PAT排名汇总"><a href="#7-4-PAT排名汇总" class="headerlink" title="7-4 PAT排名汇总"></a>7-4 PAT排名汇总</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相同情况按学号排大小</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string id = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> exam = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> grade = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rank_all = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rank_exam = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> Student&amp; a, <span class="type">const</span> Student&amp; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.grade == b.grade) &#123; <span class="keyword">return</span> a.id &lt; b.id; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> a.grade &gt; b.grade; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Student&gt; all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        vector&lt;Student&gt; v;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            Student temp;</span><br><span class="line">            temp.exam = i;</span><br><span class="line">            cin &gt;&gt; temp.id &gt;&gt; temp.grade;</span><br><span class="line">            v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;Student&gt;());<span class="comment">//降序，默认升序</span></span><br><span class="line">        <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                v[j].rank_exam = rank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j].grade == v[j - <span class="number">1</span>].grade) &#123;</span><br><span class="line">                    v[j].rank_exam = rank;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    rank = j + <span class="number">1</span>;</span><br><span class="line">                    v[j].rank_exam = rank;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum += n;</span><br><span class="line">        all.<span class="built_in">insert</span>(all.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;Student&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            all[j].rank_all = rank;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (all[j].grade == all[j - <span class="number">1</span>].grade) &#123;</span><br><span class="line">                all[j].rank_all = rank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rank = j + <span class="number">1</span>;</span><br><span class="line">                all[j].rank_all = rank;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">        cout &lt;&lt; all[i].id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].rank_all &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].exam &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].rank_exam &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>含bug<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string id = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> exam = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> grade = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rank_all = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rank_exam = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> Student&amp; a, <span class="type">const</span> Student&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.grade &gt; b.grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Student&gt; all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        vector&lt;Student&gt; v;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            Student temp;</span><br><span class="line">            temp.exam = i;</span><br><span class="line">            cin &gt;&gt; temp.id &gt;&gt; temp.grade;</span><br><span class="line">            v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;Student&gt;());<span class="comment">//降序，默认升序</span></span><br><span class="line">        <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                v[j].rank_exam = rank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j].grade == v[j - <span class="number">1</span>].grade) &#123;</span><br><span class="line">                    v[j].rank_exam = rank;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    rank = j + <span class="number">1</span>;</span><br><span class="line">                    v[j].rank_exam = rank;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum += n;</span><br><span class="line">        all.<span class="built_in">insert</span>(all.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;Student&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; </span><br><span class="line">            all[j].rank_all = rank; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (all[j].grade == all[j - <span class="number">1</span>].grade) &#123;</span><br><span class="line">                all[j].rank_all = rank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rank = j + <span class="number">1</span>;</span><br><span class="line">                all[j].rank_all = rank;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">        cout &lt;&lt; all[i].id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].rank_all &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].exam &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].rank_exam &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试用例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">1</span><br><span class="line">1234567890001 100</span><br><span class="line">2</span><br><span class="line">1234567890002 99</span><br><span class="line">1234567890020 100</span><br><span class="line">2</span><br><span class="line">1234567890003 100</span><br><span class="line">1234567890033 98</span><br><span class="line">1</span><br><span class="line">1234567890004 97</span><br><span class="line">2</span><br><span class="line">1234567890005 96</span><br><span class="line">1234567890025 99</span><br><span class="line">1</span><br><span class="line">1234567890006 95</span><br><span class="line">1</span><br><span class="line">1234567890007 93</span><br><span class="line">3</span><br><span class="line">1234567890015 94</span><br><span class="line">1234567890016 91</span><br><span class="line">1234567890017 90</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/31/PTA/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="7-1-字符串关键字的散列映射"><a href="#7-1-字符串关键字的散列映射" class="headerlink" title="7-1 字符串关键字的散列映射"></a>7-1 字符串关键字的散列映射</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">int getHkey(string s, int m);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">	cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">	cout.tie(0);</span><br><span class="line">	</span><br><span class="line">	int N, P, num;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; P;</span><br><span class="line">	int Hash[P];</span><br><span class="line">	memset(Hash, -1, sizeof(Hash));</span><br><span class="line">	map&lt;string, int&gt; m;</span><br><span class="line">	</span><br><span class="line">	for(int i =0; i &lt; N; i++)&#123;</span><br><span class="line">		if(i)&#123;</span><br><span class="line">			cout &lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		if(m.count(s) == 1)&#123;</span><br><span class="line">			cout &lt;&lt; m[s];</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		num = getHkey(s, P);//得到H（Key） </span><br><span class="line">		int k = 1, temp = num;</span><br><span class="line">		</span><br><span class="line">		//</span><br><span class="line">		while(Hash[temp] != -1)&#123;</span><br><span class="line">			temp = num;</span><br><span class="line">			if(k % 2)&#123;//奇数为正</span><br><span class="line">			    temp = (temp + (int)pow((k + 1) /2, 2)) % P;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				temp = (temp - (int)pow((k + 1) /2, 2) + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		Hash[temp] = 1;</span><br><span class="line">		m[s] = temp;</span><br><span class="line">		cout &lt;&lt; temp;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getHkey(string s, int m)&#123;</span><br><span class="line">	reverse(s.begin(), s.end());</span><br><span class="line">	int p = 0, sum = 0;</span><br><span class="line">	for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">		sum += (s[i] - &#x27;A&#x27;) * pow(32, p);</span><br><span class="line">		p++;</span><br><span class="line">		if(p == 3)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum % m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-集合的模拟实现（类模板）"><a href="#7-2-集合的模拟实现（类模板）" class="headerlink" title="7-2 集合的模拟实现（类模板）"></a>7-2 集合的模拟实现（类模板）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class MySet &#123;</span><br><span class="line">public:</span><br><span class="line">	MySet() &#123; count = 0; &#125;</span><br><span class="line">	int simple_find(T elem);</span><br><span class="line">	void addSet(T elem);</span><br><span class="line">	void delSet(T elem);</span><br><span class="line">	void findElem(T elem);</span><br><span class="line">private:</span><br><span class="line">	T data[100];//用数组来存放所有的集合元素，最多不超过100个元素</span><br><span class="line">	int count;//表示目前集合中有多少个元素</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类外成员函数实现 </span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int MySet&lt;T&gt;::simple_find(T elem) &#123;</span><br><span class="line">	for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">		if (data[i] == elem) &#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void MySet&lt;T&gt;::addSet(T elem) &#123;</span><br><span class="line">	if (this-&gt;count &gt;= 100) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Full Set.&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (simple_find(elem) == -1) &#123;</span><br><span class="line">			cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">			data[count++] = elem;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; elem &lt;&lt; &quot; is already exist!&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void MySet&lt;T&gt;::delSet(T elem) &#123;</span><br><span class="line">	int pos = simple_find(elem);</span><br><span class="line">	if (pos == -1) &#123;</span><br><span class="line">		cout &lt;&lt; elem &lt;&lt; &quot; is not exist!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">		for (int i = pos; i &lt; count - 1; i++) &#123;</span><br><span class="line">			data[i] = data[i + 1];</span><br><span class="line">		&#125;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void MySet&lt;T&gt;::findElem(T elem) &#123;</span><br><span class="line">	int x = simple_find(elem);</span><br><span class="line">	if (x == -1) &#123;</span><br><span class="line">		cout &lt;&lt; elem &lt;&lt; &quot; is not exist!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">	cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">	cout.tie(0);</span><br><span class="line"></span><br><span class="line">	MySet&lt;int&gt; inSet;</span><br><span class="line">	MySet&lt;double&gt; douSet;</span><br><span class="line">	MySet&lt;string&gt; strSet;</span><br><span class="line"></span><br><span class="line">	int type;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		cin &gt;&gt; type;</span><br><span class="line">		if (type == 0) break;</span><br><span class="line"></span><br><span class="line">		if (type == 1) &#123;</span><br><span class="line">			int ops, x;</span><br><span class="line">			cin &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">			switch (ops) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				inSet.addSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				inSet.delSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				inSet.findElem(x);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (type == 2) &#123;</span><br><span class="line">			int ops;</span><br><span class="line">			double x;</span><br><span class="line">			cin &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">			switch (ops) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				douSet.addSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				douSet.delSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				douSet.findElem(x);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (type == 3) &#123;</span><br><span class="line">			int ops;</span><br><span class="line">			string x;</span><br><span class="line">			cin &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">			switch (ops) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				strSet.addSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				strSet.delSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				strSet.findElem(x);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-集合相似度"><a href="#7-3-集合相似度" class="headerlink" title="7-3 集合相似度"></a>7-3 集合相似度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; s[51];</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int k = 1;</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        while (m--) &#123;</span><br><span class="line">            int x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            s[k].insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        int d = s[a].size() + s[b].size();</span><br><span class="line">        for (auto it: s[a]) &#123;</span><br><span class="line">            if (s[b].find(it) != s[b].end()) &#123; count++;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        double p = count * 100.0 / (d - count);//d - count为两个集合的交集</span><br><span class="line">        printf(&quot;%.2f%\n&quot;, p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-构造散列表"><a href="#7-4-构造散列表" class="headerlink" title="7-4 构造散列表"></a>7-4 构造散列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int a1[18], a2[18];</span><br><span class="line">    for (int i = 0; i &lt; 18; i++) &#123; a1[i] = 0; &#125;</span><br><span class="line">    int n, num, temp;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        a2[i] = num;</span><br><span class="line">        temp = num % 17;// 计算 num 的哈希值（模 17）</span><br><span class="line"></span><br><span class="line">        // 哈希冲突</span><br><span class="line">        // 采用线性探测法（每次偏移 5）寻找下一个空位</span><br><span class="line">        while (a1[temp] != 0) &#123;</span><br><span class="line">            temp = (temp + 5) % 18;</span><br><span class="line">        &#125;</span><br><span class="line">        a1[temp] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 18; j++) &#123;</span><br><span class="line">            if (a1[j] != 0 &amp;&amp; a1[j] == a2[i]) &#123;</span><br><span class="line">                cout &lt;&lt; a2[i] &lt;&lt; &quot; pos: &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-整型关键字的平方探测法散列"><a href="#7-5-整型关键字的平方探测法散列" class="headerlink" title="7-5 整型关键字的平方探测法散列"></a>7-5 整型关键字的平方探测法散列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">bool isPrime(long n) &#123;</span><br><span class="line">    if (n &lt; 2) &#123; return false; &#125;</span><br><span class="line">    for (long i = 2; i * i &lt;= n; i++) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int m, n;</span><br><span class="line">    int s, p, v[10007] = &#123; 0 &#125;;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    while (!isPrime(m)) &#123; m++; &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        p = -1;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            //二次探测法查找空位</span><br><span class="line">            if (!v[(s + j * j) % m]) &#123;</span><br><span class="line">                v[(s + j * j) % m] = 1;</span><br><span class="line">                p = (s + j * j) % m;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //输出结果</span><br><span class="line">        if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125;//如果不是第一个输出，先输出空格</span><br><span class="line">        if (p == -1) &#123; cout &lt;&lt; &quot;-&quot;; &#125;</span><br><span class="line">        else &#123; cout &lt;&lt; p; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/12/31/PTA/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="7-1-银行业务队列简单模拟"><a href="#7-1-银行业务队列简单模拟" class="headerlink" title="7-1 银行业务队列简单模拟"></a>7-1 银行业务队列简单模拟</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N; <span class="comment">// 读取顾客总数</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; A, B; <span class="comment">// A窗口和B窗口的队列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result; <span class="comment">// 存储结果的向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取顾客编号，并分配到不同的窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> customer;</span><br><span class="line">        cin &gt;&gt; customer;</span><br><span class="line">        <span class="keyword">if</span> (customer % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            A.<span class="built_in">push</span>(customer); <span class="comment">// 奇数顾客到A窗口</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.<span class="built_in">push</span>(customer); <span class="comment">// 偶数顾客到B窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟处理顾客</span></span><br><span class="line">    <span class="keyword">while</span> (!A.<span class="built_in">empty</span>() || !B.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 处理A窗口的顾客</span></span><br><span class="line">        <span class="keyword">if</span> (!A.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(A.<span class="built_in">front</span>()); <span class="comment">// 处理一个A窗口的顾客</span></span><br><span class="line">            A.<span class="built_in">pop</span>(); <span class="comment">// 移除已处理的顾客</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理A窗口的第二个顾客（如果有）</span></span><br><span class="line">        <span class="keyword">if</span> (!A.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(A.<span class="built_in">front</span>());</span><br><span class="line">            A.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理B窗口的顾客</span></span><br><span class="line">        <span class="keyword">if</span> (!B.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(B.<span class="built_in">front</span>()); <span class="comment">// 处理一个B窗口的顾客</span></span><br><span class="line">            B.<span class="built_in">pop</span>(); <span class="comment">// 移除已处理的顾客</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; result[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; result.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 在数字之间输出空格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">// 输出换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-2-Windows消息队列"><a href="#7-2-Windows消息队列" class="headerlink" title="7-2 Windows消息队列"></a>7-2 Windows消息队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">char</span> message[<span class="number">11</span>];</span><br><span class="line">	<span class="type">int</span> rank;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node a, node b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.rank &gt; b.rank;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;<span class="comment">//有序队列，按数字进行从大到小排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string op;</span><br><span class="line">	node p;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; p.message &gt;&gt; p.rank;</span><br><span class="line">			q.<span class="built_in">push</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				cout &lt;&lt; q.<span class="built_in">top</span>().message &lt;&lt; endl;</span><br><span class="line">				q.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;EMPTY QUEUE!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-银行排队问题之单队列多窗口服务"><a href="#7-3-银行排队问题之单队列多窗口服务" class="headerlink" title="7-3 银行排队问题之单队列多窗口服务"></a>7-3 银行排队问题之单队列多窗口服务</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">customer</span>&#123; <span class="comment">// 定义顾客结构体</span></span><br><span class="line">    <span class="type">int</span> T, P;</span><br><span class="line">&#125; customer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    customer cus[<span class="number">1010</span>];</span><br><span class="line">    <span class="type">int</span> i, N, K;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> done_time[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;, done_num[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 初始化每个窗口的完成时间和服务顾客数</span></span><br><span class="line">    <span class="type">int</span> wait_time_all = <span class="number">0</span>, wait_time_max = <span class="number">0</span>, wait_time_one = <span class="number">0</span>;<span class="comment">// 总的等待时间，最长等待时间，单次等待时间</span></span><br><span class="line">    <span class="type">int</span> flag, done_time_min, done_time_max = <span class="number">0</span>, mark;<span class="comment">// 是否需要等待的标记，所有窗口中的最小完成时间和最大完成时间，以及相应窗口的序号</span></span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (rear = <span class="number">0</span>; rear &lt; N; rear++) &#123;</span><br><span class="line">        cin &gt;&gt; cus[rear].T &gt;&gt; cus[rear].P;</span><br><span class="line">        <span class="keyword">if</span> (cus[rear].P &gt; <span class="number">60</span>) &#123; cus[rear].P = <span class="number">60</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>, done_time_min = <span class="number">9999</span>, mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (done_time[i] &lt;= cus[front].T) &#123;<span class="comment">// 队首顾客到达时间在最小完成时间后就不需要等待</span></span><br><span class="line">                done_time[i] = cus[front].T + cus[front].P;<span class="comment">// 新的完成时间为新顾客到达时间+事务处理时间</span></span><br><span class="line">                done_num[i]++;<span class="comment">// 服务顾客数+1</span></span><br><span class="line">                flag = <span class="number">1</span>;<span class="comment">// 置1表示无需等待</span></span><br><span class="line">                front++;<span class="comment">// 队首顾客出队</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不满足前一个条件，即完成时间在顾客到达时间之后，顾客需要等待</span></span><br><span class="line">            <span class="keyword">if</span> (done_time_min &gt; done_time[i]) &#123;</span><br><span class="line">                <span class="comment">// 记录该窗口的完成时间和窗口序号，k次循环后留下的即是最小完成时间和对应窗口序号</span></span><br><span class="line">                done_time_min = done_time[i];</span><br><span class="line">                mark = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;<span class="comment">// flag = 0为需要等待</span></span><br><span class="line">            wait_time_one = done_time_min - cus[front].T;</span><br><span class="line">            <span class="keyword">if</span> (wait_time_max &lt; wait_time_one) &#123;</span><br><span class="line">                wait_time_max = wait_time_one;</span><br><span class="line">            &#125;</span><br><span class="line">            wait_time_all += wait_time_one;</span><br><span class="line">            done_time[mark] = done_time_min + cus[front].P;</span><br><span class="line">            done_num[mark]++;</span><br><span class="line">            front++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (done_time_max &lt; done_time[i]) &#123;</span><br><span class="line">            done_time_max = done_time[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f %d %d\n&quot;</span>, <span class="number">1.0</span> * (wait_time_all / N), wait_time_max, done_time_max);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        cout &lt;&lt; done_num[i];</span><br><span class="line">        <span class="keyword">if</span> (i == K - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-列车调度"><a href="#7-4-列车调度" class="headerlink" title="7-4 列车调度"></a>7-4 列车调度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    v.<span class="built_in">push_back</span>(last);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now &gt; last) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), now) - v.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (pos != v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                k = <span class="number">1</span>;</span><br><span class="line">                v[pos] = now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!k) &#123; v.<span class="built_in">push_back</span>(now); &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), now) - v.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (pos != v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                v[pos] = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = now;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>笛卡尔树</title>
    <url>/2024/12/31/PTA/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/</url>
    <content><![CDATA[<p>笛卡尔树是一种特殊的二叉树，其结点包含两个关键字K1和K2。首先笛卡尔树是关于K1的二叉搜索树，即结点左子树的所有K1值都比该结点的K1值小，右子树则大。其次所有结点的K2关键字满足优先队列（不妨设为最小堆）的顺序要求，即该结点的K2值比其子树中所有结点的K2值小。给定一棵二叉树，请判断该树是否笛卡尔树。</p>
<p>输入格式:<br>输入首先给出正整数N（≤1000），为树中结点的个数。随后N行，每行给出一个结点的信息，包括：结点的K1值、K2值、左孩子结点编号、右孩子结点编号。设结点从0~(N-1)顺序编号。若某结点不存在孩子结点，则该位置给出−1。</p>
<p>输出格式:<br>输出YES如果该树是一棵笛卡尔树；否则输出NO。</p>
<h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">27</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">9</span> <span class="number">40</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">12</span> <span class="number">21</span> <span class="number">-1</span> <span class="number">4</span></span><br><span class="line"><span class="number">15</span> <span class="number">22</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">5</span> <span class="number">35</span> <span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>
<h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">27</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">9</span> <span class="number">40</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">12</span> <span class="number">11</span> <span class="number">-1</span> <span class="number">4</span></span><br><span class="line"><span class="number">15</span> <span class="number">22</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">50</span> <span class="number">35</span> <span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k1, k2;</span><br><span class="line">	<span class="type">int</span> left, right;</span><br><span class="line">&#125; node[<span class="number">1010</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> vis[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node[root].left != <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">BST</span>(node[root].left);</span><br><span class="line">	t.<span class="built_in">push_back</span>(node[root].k1);</span><br><span class="line">	<span class="keyword">if</span> (node[root].right != <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">BST</span>(node[root].right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBST</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">BST</span>(root);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (t[i] &gt; t[i + <span class="number">1</span>])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMinHeap</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (node[root].left != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node[node[root].left].k2 &lt; node[root].k2)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isMinHeap</span>(node[root].left))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (node[root].right != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node[node[root].right].k2 &lt; node[root].k2)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isMinHeap</span>(node[root].right))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; node[i].k1 &gt;&gt; node[i].k2 &gt;&gt; node[i].left &gt;&gt; node[i].right;</span><br><span class="line">		<span class="keyword">if</span> (node[i].left != <span class="number">-1</span>)</span><br><span class="line">			vis[node[i].left] = <span class="number">1</span>;<span class="comment">//非根节点置1</span></span><br><span class="line">		<span class="keyword">if</span> (node[i].right != <span class="number">-1</span>)</span><br><span class="line">			vis[node[i].right] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">if</span> (vis[i] == <span class="number">0</span>)</span><br><span class="line">			root = i;<span class="comment">//找到根节点编号</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isBST</span>(root) &amp;&amp; <span class="built_in">isMinHeap</span>(root))</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
