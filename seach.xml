<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/12/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>计算机小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
    <content><![CDATA[<p><strong>7-1 根据后序和中序遍历输出前序遍历</strong></p>
<p>分数 25</p>
<p>作者 DS课程组</p>
<p>单位 浙江大学</p>
<p>本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的前序遍历结果。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行给出正整数 <em>n</em> (≤30)，是树中结点的个数。随后两行，每行给出 <em>n</em> 个整数，分别对应后序遍历和中序遍历结果，数字间以空格分隔。题目保证输入正确对应一棵二叉树。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出<code>Preorder:</code>以及该树的前序遍历结果。数字间有1个空格，行末不得有多余空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Preorder: 4 1 3 2 6 5 7</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode* lchild;</span><br><span class="line">	TreeNode* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode* T)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	TreeNode* T;</span><br><span class="line">	<span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span>* inorder = new <span class="type">int</span>[n];</span><br><span class="line">	<span class="type">int</span>* postorder = new <span class="type">int</span>[n];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; postorder[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; inorder[i];</span><br><span class="line">	&#125;</span><br><span class="line">    T = buildTree(inorder, postorder, n);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Preorder:&quot;</span>;</span><br><span class="line">	preorderTraversal(T);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	TreeNode* T;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!n) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T = new TreeNode;</span><br><span class="line">	T-&gt;val = postorder[n - <span class="number">1</span>];</span><br><span class="line">	T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inorder[i] == postorder[n - <span class="number">1</span>]) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	T-&gt;lchild = buildTree(inorder, postorder, i);</span><br><span class="line">	T-&gt;rchild = buildTree(inorder + i + <span class="number">1</span>, postorder + i, n - i - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorderTraversal</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; T-&gt;val;</span><br><span class="line">	preorderTraversal(T-&gt;lchild);</span><br><span class="line">	preorderTraversal(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>123</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2024/12/31/test/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a7074f51470a8d4b1da7963a345805ce2e2a8f0f973f6dce5c290a9160802f99">1b693c4938223286468132b2f7068bf6414acddc3954a6e747562ccd80f9367d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>计算机小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>经典排序算法</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="经典排序算法"><a href="#经典排序算法" class="headerlink" title="经典排序算法"></a>经典排序算法</h1><p>预定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Ty int <span class="comment">// 以整型为例</span></span></span><br></pre></td></tr></table></figure>
<p>交换数据的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Ty* elems,<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    Ty temp=elems[i];</span><br><span class="line">    elems[i]=elems[j];</span><br><span class="line">    elems[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果确认只用整型数据使用下面的代码会更快，因为减少了函数压栈，也使用了位运算</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP_INT(a, b) \</span></span><br><span class="line"><span class="meta">    &#123;                  \</span></span><br><span class="line"><span class="meta">        a = (a) ^ (b); \</span></span><br><span class="line"><span class="meta">        b = (a) ^ (b); \</span></span><br><span class="line"><span class="meta">        a = (a) ^ (b); \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>原理：将一段序列的最大值（最小值）拿到最左边或者最右边的操作，使用循环重复操作，（每轮排序都会少一个最大值或最小值），当最后只剩下一个数据的时候整个序列就已经排好序了。<br>冒泡排序的原理很简单，使用代码实现也很简单。也是所有排序算法里面最简单的一个。<br>具体代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubSort</span><span class="params">(Ty* elems,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;size--) &#123;    <span class="comment">//轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; size;j++) &#123;    <span class="comment">//找剩余元素中的最值</span></span><br><span class="line">            <span class="keyword">if</span> (elems[j] &lt; elems[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(elems,j,j<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubSort</span><span class="params">(Ty* elems,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;size;j++)</span><br><span class="line">            <span class="keyword">if</span>(elems[i]&lt;elems[j])</span><br><span class="line">                <span class="built_in">swap</span>(elems,i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接使用两层循环去实现，外层循环主要作用是存放最大值或最小值的，内存循环的主要作用是找到发生冲突的元素，如果发生冲突就交换两个数据。当两层循环的结束的时候整个序列就自然排好序了。时间复杂度为O(n^2).</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>原理：基本思想和冒泡排序是一样的，选择排序相对于冒泡排序的优点就是减少交换次数。算法思想都是在序列中找到最大值（最小值），然后存放好下次进入循环就访问不到这个最大值（最小值）。当两层循环都结束的时候序列就自然排好了。<br>具体代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(Ty* elems,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> minPos=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;size;j++)</span><br><span class="line">              <span class="keyword">if</span>(elems[minPos]&gt;elems[j])</span><br><span class="line">                minpos=j;</span><br><span class="line">        <span class="built_in">swap</span>(elems,i,minPos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>原理：基本思想还是冒泡排序，不过插入排序是两边相靠的冒泡，所以在序列部分有序的情况下，插入排序的效率要比冒泡排序效率高。从序列的尾部开始往前比较，如果当前的数据小于（大于）前一个的数据就进行交换，否则进入下一次循环，直到外层循环遍历完整个序列就自然排好序了。<br>具体代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(Ty* elems,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; size;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j &gt; <span class="number">0</span> &amp;&amp; elems[j<span class="number">-1</span>] &gt; elems[j];j--)</span><br><span class="line">            <span class="built_in">swap</span>(elems,j<span class="number">-1</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(Ty* elems,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; size;i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="type">int</span> temp = arr[j];</span><br><span class="line">        <span class="keyword">for</span> (;j &gt;= <span class="number">1</span> &amp;&amp; temp &lt; arr[j<span class="number">-1</span>];j--)</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>原理：希尔排序是建立在插入排序的基础上进行优化的排序算法，所以希尔排序又叫做优化版的插入排序。<br>代码实现：</p>
<ol>
<li>将间隔定为4</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(Ty* elems,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">4</span>;h &gt;= <span class="number">1</span>;h = h &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h;i &lt; size;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i;j &gt;= h &amp;&amp; elems[j] &gt; elems[j-h];j -= h)</span><br><span class="line">                <span class="built_in">swap</span>(elems,j,j-h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用常用的序列号</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(Ty* elems,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; size/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h;i &lt; size;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i;j &gt;= h &amp;&amp; elems[j] &gt; elems[j-h];j -= h)</span><br><span class="line">                <span class="built_in">swap</span>(elems,j,j-h);</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(Ty* elems,<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> t = length/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; t) h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h;i &lt; length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = h;</span><br><span class="line">            Ty temp = arr[j];</span><br><span class="line">            <span class="keyword">for</span> (;j &gt;= h &amp;&amp; temp &lt; arr[j-h];j-=h)</span><br><span class="line">                arr[j] = arr[j-h];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 实例解释</span><br><span class="line">size=<span class="number">13</span>,h=<span class="number">4</span> <span class="meta"># h=13/3</span></span><br><span class="line">        h</span><br><span class="line">        |</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">7</span> <span class="number">9</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">10</span> <span class="number">0</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line">        ||</span><br><span class="line">        ij</span><br><span class="line"># <span class="number">4</span>&lt;<span class="number">9</span> so i++;j=i</span><br><span class="line">        h</span><br><span class="line">        |</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">7</span> <span class="number">9</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">10</span> <span class="number">0</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line">          ||</span><br><span class="line">          ij</span><br><span class="line"># <span class="number">6</span>&gt;<span class="number">5</span> 交换 j-=h</span><br><span class="line">        h</span><br><span class="line">        |</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">7</span> <span class="number">9</span> <span class="number">6</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">10</span> <span class="number">0</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line">  |          |</span><br><span class="line">  j          i</span><br><span class="line"><span class="meta"># j&lt;h i++;j=i</span></span><br><span class="line"># 依此类推</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>原理：快速排序的核心思想是设立一个轴，然后其他数据都和这个轴作比较，最后把轴放在序列的中间，执行完一遍快速排序后左边的数据都比轴小，右边的数据都比轴大。然后递归下去，当递归结束的时候就拍好序了。快速排序的排序很快，但是当数据形成一边倒的情况的时候就发挥不出快速排序的优势。<br>具体代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//稍微修改一下适用于单链表的快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(Ty *elems, <span class="type">int</span> first, <span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last || first &lt; <span class="number">0</span> || last &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Ty privot = elems[first];</span><br><span class="line">    <span class="type">int</span> i = first + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = first + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elems[j] &lt; privot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(&amp;elems[i], &amp;elems[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;elems[first], &amp;elems[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">quickSort</span>(elems, first, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(elems, i, last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仅仅适用于数组的快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(Ty* elems,<span class="type">int</span> left,<span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    Ty privot = elems[i];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= privot) --j;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= privot) ++i;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = privot;</span><br><span class="line">    <span class="built_in">quickSort</span>(elems,left,i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(elems,i + <span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>原理：把要排序的序列拆分成多个含有一个数据的序列，然后按照从小到大（从大到小）进行合并，这样就自然的将无序的序列排好序。<br>具体代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>* temp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) temp[k++] = arr[i] &lt; arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = left;i &lt;= right;i++)</span><br><span class="line">        arr[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span>* temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">merge_sort</span>(arr,left,mid,temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(arr,mid + <span class="number">1</span>,right,temp);</span><br><span class="line">    <span class="built_in">merge</span>(arr,left,mid,right,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*length);</span><br><span class="line">    <span class="built_in">assert</span>(temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(arr,<span class="number">0</span>,length - <span class="number">1</span>,temp);</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆分有小顶堆和大顶堆，而堆排序又分有外堆和内堆。</p>
<ul>
<li>外堆<br>意思是，而外申请一段和原来数组一样大的内存大小，并将数组的元素构造成小顶堆或大顶堆。根据排序的顺序和逆序确定要构成的堆结构是大顶堆还是小顶堆。现以最终序列是顺序排序（从小到大）为例，则需要构成的堆结构是小顶堆。因为小顶堆可以快速的找到序列的最小值，如果将小顶堆的数据依次弹出，则每次弹的都是剩余序列的最小值，并且每次弹出就放到原来的数组中，当小顶堆里的数据都弹出来完了，原来的数组也自然有序了。如果要求最终序列是逆序的则构造的堆结构是大顶堆，然后操作是一样的。时间复杂度是O(nlogn). 空间复杂度是O(n).</li>
<li>内堆<br>意思是，不需要额外申请空间，直接在原来的数组上进行操作。现以最终序列是顺序排序（从小到大）为例，则需要构成的堆结构是大顶堆。在原来的数组上构造堆结构称之为 “堆化” ，heapify.形成大顶堆后，将堆顶依次弹出并立即放数组的尾部，反复操作此步骤直到最后一个数据，最终自然形成从小到大依次排好序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外堆</span></span><br><span class="line"><span class="comment">//堆的结构体描述</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    Ty* root;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建堆内存</span></span><br><span class="line"><span class="function">Heap* <span class="title">creatHeap</span><span class="params">(<span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Heap* heap = (Heap*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Heap));</span><br><span class="line">    <span class="built_in">assert</span>(heap);</span><br><span class="line">    heap-&gt;root = (Ty*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Ty) * (capacity<span class="number">+1</span>) );</span><br><span class="line">    heap-&gt;size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入堆</span></span><br><span class="line"><span class="comment">//先将要插入的数据插入到堆的尾部，然后向上渗透，爬到对应的位置，就把数据放进去即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushHeap</span><span class="params">(Heap* heap,Ty data)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> current = heap-&gt;size++;</span><br><span class="line">    <span class="type">int</span> parent  = current &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    heap-&gt;root[current] = data;</span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap-&gt;root[current] &lt; heap-&gt;root[parent]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap-&gt;root,current,parent);    </span><br><span class="line">            current = parent;</span><br><span class="line">            parent &gt;&gt;= <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出堆</span></span><br><span class="line"><span class="comment">//先将堆顶元素保存下来，然后使用堆的尾部覆盖堆顶，然后往下渗透，走到对应的位置，就把数据放进去，然后返回保存的元素</span></span><br><span class="line"><span class="function">Ty <span class="title">popHeap</span><span class="params">(Heap* heap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> current = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rchild  = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> n = --heap-&gt;size;</span><br><span class="line">    Ty ret = heap-&gt;root[<span class="number">1</span>];</span><br><span class="line">    heap-&gt;root[<span class="number">1</span>] = heap-&gt;root[n];</span><br><span class="line">    <span class="keyword">while</span> (rchild &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> small = heap-&gt;root[rchild - <span class="number">1</span>] &lt; heap-&gt;root[rchild] ? rchild - <span class="number">1</span> : rchild;</span><br><span class="line">        <span class="keyword">if</span> (heap-&gt;root[small] &lt; heap-&gt;root[current]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap-&gt;root,current,small);</span><br><span class="line">            current = small;</span><br><span class="line">            rchild  = (current &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内堆</span></span><br><span class="line"><span class="comment">//在原来数组的基础上直接操作，其实就是入堆和出队直接结合，不需要额外申请空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> current,<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rchild = (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> large;</span><br><span class="line">    <span class="keyword">while</span> (rchild &lt;= length &amp;&amp; (arr[large = rchild == length ? rchild<span class="number">-1</span> : (arr[rchild<span class="number">-1</span>] &gt; arr[rchild] ? rchild<span class="number">-1</span> : rchild)] &gt; arr[current])) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,large,current);</span><br><span class="line">        current = large;</span><br><span class="line">        rchild  = (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> current = length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &gt;= <span class="number">0</span>) <span class="built_in">heapify</span>(arr,current--,length);</span><br><span class="line">    <span class="keyword">while</span> (length) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,<span class="number">0</span>,--length);</span><br><span class="line">        <span class="built_in">heapify</span>(arr,<span class="number">0</span>,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>前面的算法都是基于比较的排序，计数排序是利用了数组的下标天然有序原理进行排序，所以计数排序是基于统计而排序的排序算法。算法的核心思想是遍历一个无序数组，将遍历到的数据按它的数值找到统计数组的对应下标将其放入统计数组中，依次类推，直到无序的数组的每一个数据都被遍历完之后统计数组也已经初始化完毕，接下来就是遍历统计数组如果遍历到的空间是大于零的就将其下标存入原来的数组中，直到统计数组被遍历完，最终可以排好序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> length,<span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* count = (<span class="type">int</span>*)<span class="built_in">calloc</span>(max,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; length;i++) &#123;</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; max;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i]--)</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>桶排序的思想，按照数字的位数进行排序，准备0-9的链式队列，从低位开始到高位进行排序，当最高位被排好序后原来的序列自然排好序了。<br>例如：对以下序列进行基数排序<br>578，234，86，432，512，618，384<br>排序过程：<br>第一轮（在第零轮的基础上按位排在第零轮的基础上按位排在第零轮的基础上按100位排）：432，512，234，384，86，578，618<br>第二轮（在第一轮的基础上按位排在第一轮的基础上按位排在第一轮的基础上按101位排）：512，618，432，234，578，384，86<br>第三轮（在第二轮的基础上按位排在第二轮的基础上按位排在第二轮的基础上按102位排）：86，234，384，432，512，578，618<br>第三轮结束序列自然排好序。<strong>86不够3位数，就往前面补零，即86 = 086</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">redixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> ii;</span><br><span class="line">    <span class="type">int</span> jj;</span><br><span class="line">    <span class="type">int</span> temp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">10</span>; ii++)</span><br><span class="line">        <span class="keyword">for</span> (jj = <span class="number">0</span>; jj &lt; <span class="number">10</span>; jj++)</span><br><span class="line">            temp[ii][jj] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">10</span>; k &lt; <span class="number">10000</span>; k *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> index = (arr[i] % k) / (k / <span class="number">10</span>);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp[index][j] != <span class="number">-1</span>)</span><br><span class="line">                j++;</span><br><span class="line">            temp[index][j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">10</span>; ii++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (jj = <span class="number">0</span>; jj &lt; length &amp;&amp; temp[ii][jj] != <span class="number">-1</span>; jj++) &#123;</span><br><span class="line">                arr[i++] = temp[ii][jj];</span><br><span class="line">                temp[ii][jj] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>文件管理器</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/FZU_DS/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p><strong>测试用例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 10 1</span><br><span class="line">1 2 20 2</span><br><span class="line">1 2 30 3</span><br><span class="line">1 2 40 3</span><br><span class="line">1 2 50 3</span><br><span class="line">3 1 5</span><br><span class="line">4 1 9</span><br><span class="line">3 2 3</span><br><span class="line">4 2 3</span><br><span class="line">4 2 10</span><br></pre></td></tr></table></figure>
<h3 id="mine"><a href="#mine" class="headerlink" title="mine"></a>mine</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max1 = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max2 = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">	<span class="type">int</span> name;<span class="comment">//文件名</span></span><br><span class="line">	<span class="type">int</span> size;<span class="comment">//大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;File&gt; folders[<span class="number">5</span>];<span class="comment">//文件夹</span></span><br><span class="line">	<span class="type">int</span> Q;</span><br><span class="line">	cin &gt;&gt; Q;</span><br><span class="line">	<span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">		<span class="type">int</span> op;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="type">int</span> folder, name, size, k;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">			cin &gt;&gt; folder &gt;&gt; name &gt;&gt; size;</span><br><span class="line">			vector&lt;File&gt;::iterator it = <span class="built_in">find_if</span>(folders[folder].<span class="built_in">begin</span>(), folders[folder].<span class="built_in">end</span>(), [name](File f) &#123;<span class="keyword">return</span> f.name == name; &#125;);<span class="comment">//匿名函数</span></span><br><span class="line">			<span class="keyword">if</span> (it != folders[folder].<span class="built_in">end</span>()) &#123; it-&gt;size = size; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				File f;</span><br><span class="line">				f.name = name;</span><br><span class="line">				f.size = size;</span><br><span class="line">				folders[folder].<span class="built_in">push_back</span>(f);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">			cin &gt;&gt; folder &gt;&gt; name;</span><br><span class="line">			vector&lt;File&gt;::iterator it = <span class="built_in">find_if</span>(folders[folder].<span class="built_in">begin</span>(), folders[folder].<span class="built_in">end</span>(), [name](File f) &#123;<span class="keyword">return</span> f.name == name; &#125;);<span class="comment">//匿名函数</span></span><br><span class="line">			<span class="keyword">if</span> (it != folders[folder].<span class="built_in">end</span>()) &#123; folders[folder].<span class="built_in">erase</span>(it); &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">			cin &gt;&gt; folder &gt;&gt; k;</span><br><span class="line">			<span class="built_in">sort</span>(folders[folder].<span class="built_in">begin</span>(), folders[folder].<span class="built_in">end</span>(), [](File f1, File f2) &#123;<span class="keyword">return</span> f<span class="number">1.</span>size == f<span class="number">2.</span>size ? f<span class="number">1.</span>name &lt; f<span class="number">2.</span>name : f<span class="number">1.</span>size &gt; f<span class="number">2.</span>size; &#125;);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; folders[folder].<span class="built_in">size</span>() &amp;&amp; k; i++, k--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i != <span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">				cout &lt;&lt; folders[folder][i].name;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">			cin &gt;&gt; folder &gt;&gt; k;</span><br><span class="line">			<span class="built_in">sort</span>(folders[folder].<span class="built_in">begin</span>(), folders[folder].<span class="built_in">end</span>(), [](File f1, File f2) &#123;<span class="keyword">return</span> f<span class="number">1.</span>size == f<span class="number">2.</span>size ? f<span class="number">1.</span>name &lt; f<span class="number">2.</span>name : f<span class="number">1.</span>size &lt; f<span class="number">2.</span>size; &#125;);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; folders[folder].<span class="built_in">size</span>() &amp;&amp; k; i++, k--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i != <span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">				cout &lt;&lt; folders[folder][i].name;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">doc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> name = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum;</span><br><span class="line">	cin &gt;&gt; sum;</span><br><span class="line">	vector&lt;doc&gt; v[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">		<span class="type">int</span> op;</span><br><span class="line">		<span class="type">int</span> folder, name, size, k;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">			cin &gt;&gt; folder &gt;&gt; name &gt;&gt; size;</span><br><span class="line">			vector&lt;doc&gt;::iterator i = <span class="built_in">find_if</span>(v[folder].<span class="built_in">begin</span>(), v[folder].<span class="built_in">end</span>(), [name](doc d) &#123;<span class="keyword">return</span> d.name == name; &#125;);</span><br><span class="line">			<span class="keyword">if</span> (i != v[folder].<span class="built_in">end</span>()) i-&gt;size = size;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				doc d;</span><br><span class="line">				d.name = name;</span><br><span class="line">				d.size = size;</span><br><span class="line">				v[folder].<span class="built_in">push_back</span>(d);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">			cin &gt;&gt; folder &gt;&gt; name;</span><br><span class="line">			vector&lt;doc&gt;::iterator i = <span class="built_in">find_if</span>(v[folder].<span class="built_in">begin</span>(), v[folder].<span class="built_in">end</span>(), [name](doc d) &#123;<span class="keyword">return</span> d.name == name; &#125;);</span><br><span class="line">			<span class="keyword">if</span> (i != v[folder].<span class="built_in">end</span>()) v[folder].<span class="built_in">erase</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">			cin &gt;&gt; folder &gt;&gt; k;</span><br><span class="line">			<span class="built_in">sort</span>(v[folder].<span class="built_in">begin</span>(), v[folder].<span class="built_in">end</span>(), [](doc d1, doc d2) &#123;<span class="keyword">return</span> d<span class="number">1.</span>size == d<span class="number">2.</span>size ? d<span class="number">1.</span>name &lt; d<span class="number">2.</span>name: d<span class="number">1.</span>size &gt; d<span class="number">2.</span>size; &#125;);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[folder].<span class="built_in">size</span>() &amp;&amp; k; i++, k--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[folder][i].name);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">			cin &gt;&gt; folder &gt;&gt; k;</span><br><span class="line">			<span class="built_in">sort</span>(v[folder].<span class="built_in">begin</span>(), v[folder].<span class="built_in">end</span>(), [](doc d1, doc d2) &#123;<span class="keyword">return</span> d<span class="number">1.</span>size == d<span class="number">2.</span>size ? d<span class="number">1.</span>name &lt; d<span class="number">2.</span>name: d<span class="number">1.</span>size &lt; d<span class="number">2.</span>size; &#125;);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[folder].<span class="built_in">size</span>() &amp;&amp; k; i++, k--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[folder][i].name);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 10 1</span><br><span class="line">1 2 20 2</span><br><span class="line">1 2 30 3</span><br><span class="line">1 2 40 3</span><br><span class="line">1 2 50 3</span><br><span class="line">3 1 5</span><br><span class="line"></span><br><span class="line">4 1 9</span><br><span class="line"></span><br><span class="line">3 2 3</span><br><span class="line">30 40 50</span><br><span class="line">4 2 3</span><br><span class="line">10 20 30</span><br><span class="line">4 2 10</span><br><span class="line">10 20 30 40 50</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>FZU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="7-1-根据后序和中序遍历输出前序遍历"><a href="#7-1-根据后序和中序遍历输出前序遍历" class="headerlink" title="7-1 根据后序和中序遍历输出前序遍历"></a>7-1 根据后序和中序遍历输出前序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	TreeNode* lchild;</span><br><span class="line">	TreeNode* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TreeNode* T;</span><br><span class="line">	<span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span>* inorder = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	<span class="type">int</span>* postorder = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; postorder[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; inorder[i];</span><br><span class="line">	&#125;</span><br><span class="line">    T = <span class="built_in">buildTree</span>(inorder, postorder, n);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Preorder:&quot;</span>;</span><br><span class="line">	<span class="built_in">preorderTraversal</span>(T);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="type">int</span>* inorder, <span class="type">int</span>* postorder, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	TreeNode* T;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!n) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">	T-&gt;val = postorder[n - <span class="number">1</span>];</span><br><span class="line">	T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inorder[i] == postorder[n - <span class="number">1</span>]) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	T-&gt;lchild = <span class="built_in">buildTree</span>(inorder, postorder, i);</span><br><span class="line">	T-&gt;rchild = <span class="built_in">buildTree</span>(inorder + i + <span class="number">1</span>, postorder + i, n - i - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; T-&gt;val;</span><br><span class="line">	<span class="built_in">preorderTraversal</span>(T-&gt;lchild);</span><br><span class="line">	<span class="built_in">preorderTraversal</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-完全二叉树的层序遍历"><a href="#7-2-完全二叉树的层序遍历" class="headerlink" title="7-2 完全二叉树的层序遍历"></a>7-2 完全二叉树的层序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>* tree, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> tree[maxn + <span class="number">1</span>];</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">buildTree</span>(<span class="number">1</span>,tree, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123; cout &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">		cout &lt;&lt; tree[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>*tree, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; n) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="built_in">buildTree</span>(<span class="number">2</span> * i, tree, n);</span><br><span class="line">	<span class="built_in">buildTree</span>(<span class="number">2</span> * i + <span class="number">1</span>, tree, n);</span><br><span class="line">	cin &gt;&gt; tree[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-3-树的同构"><a href="#7-3-树的同构" class="headerlink" title="7-3 树的同构"></a>7-3 树的同构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="type">int</span> lchild;</span><br><span class="line">	<span class="type">int</span> rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">buildTree</span><span class="params">(TreeNode* T)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOmorphic</span><span class="params">(<span class="type">int</span> r1, <span class="type">int</span> r2)</span></span>;</span><br><span class="line"></span><br><span class="line">TreeNode tree1[maxn], tree2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> root1, root2;</span><br><span class="line">	root1 = <span class="built_in">buildTree</span>(tree1);</span><br><span class="line">	root2 = <span class="built_in">buildTree</span>(tree2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isOmorphic</span>(root1, root2))&#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉树，返回树根，空树树根为-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">buildTree</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, check[maxn];</span><br><span class="line">	<span class="type">char</span> cl, cr;</span><br><span class="line">	<span class="type">int</span> root, i;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123; check[i] = <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; T[i].val &gt;&gt; cl &gt;&gt; cr;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (cl != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				T[i].lchild = cl - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				check[T[i].lchild] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; T[i].lchild = <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (cr != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				T[i].rchild = cr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				check[T[i].rchild] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; T[i].rchild = <span class="number">-1</span>; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回根节点</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root = i;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOmorphic</span><span class="params">(<span class="type">int</span> r1, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r1 == <span class="number">-1</span> &amp;&amp; r2 == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r1 == <span class="number">-1</span> &amp;&amp; r2 != <span class="number">-1</span>) || (r1 != <span class="number">-1</span> &amp;&amp; r2 == <span class="number">-1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tree1[r1].val != tree2[r2].val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isOmorphic</span>(tree1[r1].lchild, tree2[r2].lchild) &amp;&amp; <span class="built_in">isOmorphic</span>(tree1[r1].rchild, tree2[r2].rchild)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isOmorphic</span>(tree1[r1].lchild, tree2[r2].rchild) &amp;&amp; <span class="built_in">isOmorphic</span>(tree1[r1].rchild, tree2[r2].lchild)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的结构"><a href="#二叉搜索树的结构" class="headerlink" title="二叉搜索树的结构"></a>二叉搜索树的结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> T, n, m; <span class="comment">// 定义变量T（测试用例数），n（节点数），m（查询数）</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, lchild, rchild;</span><br><span class="line">	<span class="type">int</span> flor;<span class="comment">// 节点的层数（深度）</span></span><br><span class="line">	<span class="type">int</span> father;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode node[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索插入节点的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; node[u].x) &#123;</span><br><span class="line">		<span class="comment">// 如果x小于当前节点u的值，那么在u的左子树中</span></span><br><span class="line">		<span class="keyword">if</span> (!node[u].lchild) &#123;<span class="comment">//u没有左儿子，就让x作为左儿子</span></span><br><span class="line">			cnt++;</span><br><span class="line">			node[u].lchild = cnt;</span><br><span class="line">			node[cnt].x = x;</span><br><span class="line">			node[cnt].father = u;</span><br><span class="line">			node[cnt].flor = node[u].flor + <span class="number">1</span>;</span><br><span class="line">			mp[x] = cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//有左儿子就递归到左儿子</span></span><br><span class="line">			<span class="built_in">dfs</span>(x, node[u].lchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// x在u的右子树中</span></span><br><span class="line">		<span class="keyword">if</span> (!node[u].rchild) &#123;<span class="comment">//u没有y右儿子，就让x作为左儿子</span></span><br><span class="line">			cnt++;</span><br><span class="line">			node[u].rchild = cnt;</span><br><span class="line">			node[cnt].x = x;</span><br><span class="line">			node[cnt].father = u;</span><br><span class="line">			node[cnt].flor = node[u].flor + <span class="number">1</span>;</span><br><span class="line">			mp[x] = cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//有左儿子就递归到左儿子</span></span><br><span class="line">			<span class="built_in">dfs</span>(x, node[u].rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x; cin &gt;&gt; x;<span class="comment">//先确认根节点</span></span><br><span class="line">	node[<span class="number">1</span>].x = x;</span><br><span class="line">	node[<span class="number">1</span>].flor = <span class="number">1</span>;</span><br><span class="line">	mp[x] = <span class="number">1</span>;<span class="comment">//更新映射，将根节点值映射到索引1</span></span><br><span class="line">	cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从第二个结点开始插入</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="built_in">dfs</span>(x, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="built_in">getline</span>(cin, s); <span class="comment">//读取剩余行（防止读取到空行）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(cin, s); <span class="comment">// 读取查询语句</span></span><br><span class="line">		<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;root&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d is the root&quot;</span>, &amp;x);<span class="comment">// 从查询中解析出x</span></span><br><span class="line">			<span class="keyword">if</span> (mp[x] == <span class="number">1</span>) &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;siblings&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d and %d are siblings&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node[x].father != node[y].father) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;parent&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d is the parent of %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node[y].father == x) &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;left&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d is the left child of %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(node[y].lchild == x)&#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;right&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d is the right child of %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node[y].rchild == x) &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;level&quot;</span>) != s.npos) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(s.<span class="built_in">c_str</span>(), <span class="string">&quot;%d and %d are on the same level&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			x = mp[x]; y = mp[y];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!x || !y) &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node[x].flor == node[y].flor) &#123; cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/FZU_DS/%E5%9B%BE/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="dd899b77b76cfe52b51ee695980809df4253f4912d7e9af82d0e0e140b0884ea">10d79030e8222445804370796b90fca169b2796a276913b7c1ca4281f96701e0f530b36bf5e04ab45e385e864b80b83ebeeb11b542f77a8dffab4f877ec2822beae63174ac9d8e7e88f4a46fee1b81ce643a108b5b0cd3d137ff2599700e32793bc1bc58009d945e4a7b81c0d04fa6508ae99155b1f7db7e095fb2346f56b122bb0cfaf943499acf61426daa6404b9bf4dfe1ec5b422dc464fcd3977c6bbd9a313f6031600440fb6d490a00fc2e28b2123977d14c50e829501377a2ad34edc2d77a5c17da62039cb6ad9398ccb1af827c8780163cf354cfcd219d4a67ee18c4f5669945e6c664a6e2b06bafe9a0898cdf902e84daafc7ee4281969d6c516e3130a3678b8ce0c367cfb7692e8af55b99039cd5ced392b205098cf14d973c6555427f616491cd205e6efee9389efa2b334f65eabd5bc1cff67d44256e8b25ecb3808aa299bc0dfd6aa8c5882ce073ab60189c8243521c3e9452cb14c0b4fa88ac7791ab44517067ea3f375451616a35f27808b575f72c8eedb7d4ab65199fd7338ea1bec76c1b901022edb2cff3cd3fbc43c7f89779a50a26660f15a2e0d89dc566ab42ab10c2ff4470c43791dd2bfb89eab1fdf05cedc6d86080c5cb3e29734309460ca9a200e66816005c06636eeaf0eaa96cff3b21dc5d5f73bb73a7e6cdee76853f6870865ac6fc8ff7cf9da61ff3987ca8e838ce60ded71581c6cf6a2ee261e7fdbbceca5ef601223f15cb7075ea45672efa72579f76fc63a88eb8df8f7180b35b1e3cae601308128b8fb45fc804f7cf62cb93999988e95d4fa7d338198b58b42b05e1243ec7d5146877a2172bf08fd687465a25929c1e148153f473e31eff2d46697575d92a7b0c5bb4a478983cf9acf34f8e2defaf47fbffd12e52e633cd04167a2ea1711bd5d49a6524b351b0966f64da2cd9afedbb88d7557f6061dd70259034c019193678195ada977b87f01e22f01439a6e17b6165effa2edfcfe48eeb5e108bf0a58be83605d8928164d50552379902a6915ac63335ade699c6fd58d7fbc55280bf77e45a473aedd079780584b58ec757338a2adb10cd104dc2bb724bfc2eea3a88a47a1876e2b2ee1f1572e04503810400e70542b9c0892dd076d365269595df8cff6231fd7589fafd770aed9eca5f7c8dbc70b5a8e4a9cce7af17b83755633a8db68fd0726111e91e61208ac89e2419de89e82ebf26f9a38e8298163ebbec1ceb28e46aaaec371170d4b45637c5c974d9ffadc7e71a104796a2b9208f558b14c8b37a7cce13de067d4d475e764c98be8e4c4cfe9946a2fbd275ea7c47144619074d4a2f3ba4a32b9403b4dea4671f8bf1b94eb09f8e62810c24655c6409e6a821b458a0a81fa51d5ce6d46e29e4cbeb20e1f54b96d3e78c8592d9f13800ae0678a3919b719e93c78a39aa29c49f91a77b4229fb51500fa1aed2fad05008f85d0f75a96e21d3ce6b671f0a416563a1cec122e4a33d5ba8a154f35e7f1da6c5c4582be72c8167241cd274e0af1c0f6d984c06f10e09ccb4749c7acd55b41b634c3669620b3aabd77bc349a59db40d55a879ec4500d3e1c587addf80e6927f7b6860b91a892d3764b564405a43b24cde6bb8491c1d30e42a35e6ced440fc2f54db21edc1f9b66f98e52a061cfac99086d8963d1cd882d4630d8def0d29e5478afaa798f1327f8bedd5b3269ae4d10377d86e2df826d5df10cf1ce3ec3a602de82d113af9894ad2c1cd483a27f7f0839c444aa46aabaca021543a0ef91d8c0f12158696ffc7c30631f0a36237139100fc09cca5e51b5e84fc23e533957485465e9d3b74fe04ecb8b3a7f51644f4d7143746b180bb828b21932532d5ee41521913198312717bb82436c8036f56968c9597e6a7af0044e1d5c30c9c1eeeba470240bf74386465715efadfecb53d78e0052143afd58ed551139a81a3e96d230563aee91e9db2e6864f2c4c9dd1af959a9bdbdd6efbcc0c625dbb9e2f72346d4b00d6b2975c099b9f68100930f01a8ca004d9feb81cf0385c53e103480fc53c55bf44a1048d86b8f9a96c5d88452f6b752957be01ad8dcc766d26152175120e7c0b40833c696289b1a9fc5ffed654a0caab1f97f2526dd64a11742e7eff632f1e0f26b82f85ae80ed7abcea62f8afd3a58cd24ef9c502aa74c015b6bdbc634e32c76ec287281ca9706d36517e6a506182a0b9f9c0de09242b7e393c3caa1d4c30a5f1911068c464a465f1a4df7feb96c440028b6b6d308df0d535e54953c4d5855e8702e4d4e7bcfd040fa561709bd394b35c0e375470212ef3ebb94d3cac74f6b31b74186d44b05b2df5152598706db508eadab789794052a1313176a87b48aa5aa1072e23eb5c45a61dc290117a1eef4aed2384fdf69cacd146be5e918481789e3c337b80e3f59555793aa577663d6455cd817db857d0621227aff583f79a7d80d5b5d4660fc607a27198e8fae23f89743a139a0930386612bb915089608849c8feb8bd7b84ca63638c0d7ed874e2c46f27a2f4f132f812267029531b620fe452926c2a949ae4c09071a852ffecd19ef386d2a7c2917f1e445837c6eeaf8dc39ffe1c88152588cce957b64a1083cb9c8271ed344eb6858c9d79e9e1f28b4362178a598b5f6454c9b4f77bbaa549fac158b83c82f5bf330dd2a26faa66da9f721a7b69f8e3cdadbf2c119fd7b0444756dcb0f1b168aeae654ae2b35e3b7e8db9552dd5bd2af6f7e2db0972c9a06e38860b415f1f11192732dfb3a8e21a13f1d6642dd611af4f058c68a8f6562123cc3aee6fb20de0df7dae03cfe5bf0b8e31532c7786725c5f06a4d232f97cc221424be2014c657f711a652c8b963385cae36351233985609805840e604e2203ca3af7089b47030141e94d15a12b768e1105e398386a48d93cf95f69f852fb598042960daeab2575a6846d8b640027b97060da0ae70ca33456be3cba9e3adc696fb1086438c1188d25b4316fb5445f5a1a44d1c52140ae94d14f1036be177b14efd2afdf4db8e259f966590b5bd4628df6e584a328be560f0b3c4785c130bcdad17044871ff313ca8477533936a96fe1605d27eed1ac429d4c03e0d98fd832e80dc60381b6c9a8cf49ce494818b34a966de9259be2d3252174fd5ec750f1820be5daff2ece4156cce3763119fe4cbf72f6a43e556a94c1da68135b185352af717dbc182bb9ce38fcac44ea4a259aa98bcbc9dfa6bc4f8ad685856f921892d45631168966452388eec0ffa1768507bc12cdf2da544dcb4e93e6bf022f4bc7107248364563411f95b4bb7f6c8601fe1715b79168fb6f10279f541ab0df3574037df9f2fdbbc09505c553220e5a10a5f02278b1e7a8e5c2b5343617ed965f2e406130529208104cdd8931df1fcb8a5a90003158779c53ef6926a55d58ee50dfca74e6a2b0854895f49eb9a75da9265597e1f62f8c4f0078a6cc9730eb3babb193b3850422cac6d94917b35f7cd2dc11deeceb51379c1a8c8af44aaf1904d0529029db72b2381903663acd48f8094c2f765b65b28753b59988d0292d7fa2747af05e5935158f1aa9ffa295dd53921f4e12e34dde3731bc4a1b13d7eca70ca01d9fd53c0c6a9f353cdcd9591ee25affd6cc675e2149d796cd3b741686c6f52abf638923f096c4f22cac2d4a60d0562aaa5cade92a664476ec15c639a86db03bfab750d7fa8221953cbc7aaa6e238cec9f1592f9df602f2a5eb0fdc0888ec69719671ade73d5f754d89f1692475699067689bdcce506c50101d0bf0f9a7fba5028c6fcacfac53686825bfda567069cb4fdab2bb5ded635c267e389ead86f705db47601c69fac674f282a4d1d3dc1714b403fdcfc65fac0c5d48862dd1163991504ae67b557de4b7ca90f1f3a1222ea748260f9b3491a1ec50ddfc81d77bc3961cfa4079d2903dec6ade1ddde391b117292c3cb705bcc44f5398cf7d82ce320ce211f1c81c48afe44065848af705418b1198701cb18ac909816bfff8031f18c51813fdd7fb7fe0610038524e348fa067945abf886760a27c265f3a8e45551075dbef2c398d894d269919e1c475593bbbadc8a0d6e48f947876fec10a6e1a0538795a4dd502b137bd3ce6ca97dc2b666877cc6cd1043e50c2f63e7142c1a3f98b446faefe9368875ed3e7613a6f50a4e68daf18dd21ce6e380dbfe4284762e6760a7e2a6c7c287d128026fc08758e945fc0e5b1725e1547f6937129649ab11d7160fff24c904b682bf951c564dfd8b95c715e61b2762ce421c02089151dd065747c2e98fcd6d0812d8f08dfe0c567240cb2b301c357fc46b0408c68595d4d6735d2b312cb401ecde7970c128196abc41c2c9f6dbc9da973f8d30907ecee7babd8059813b4916a9b8a9966267bd3258ed7ca481c455c4796fcfd17c060e55c20c04cb5af840c29c4666ff0c8a0ae64047827a3eec5a2674d0de4353e543281769c106d34e46795a11759dc53b0d35a5fc4a9f6e6e09f5085bbed6cc6bd67bfe562a1b14e1f95d062a9dae0877b06ec8d51f738d3225398e1465427dc6bd3baca08c75b30f4ad73e1d706ecc4598642b3bed0fdc4b9dc8cfd68a12e19892c59ea26a485f45407778e427fd544fe8f037b004fd3163b3e8c592c6c2c2bca30f8d025ec02c58615527739fb509f8201a2a4b92dd5347f35d01909d411c5905dee8a77bdc98fcfae040cfbad59a354ffae7fc875905e3f598991815bb4d76026f3a295a408f645d914f51f42c810413e31a4158e177322b4ed0a93657a767307826792c1c86093e1cdc7a464d9d5b2d67262f34dfe9ddc53568d6e629d9788b0fdcee96e5944c61ddaaa7bbff1e827045bd1778905db1b14e65bd1965dad0f092e30b467fa294ef1edd594d99fcdb7118a5e7e90adef60fef8c24a26c4fe3fdb4e4517dc4f689761a72a5caa0d3b4698858b4cab6ac7caeee60b1655041ba3cfbc32321d899f919e546f13462f97edc2877523faa8267ac6b8aa04e3de487ad7672c64702ecdc47742884725f29091f68069978e18f6ba0267ec0492fcc36c1da7234895ca4e66b92ef6aa1291a383d0a49cd10815a82c6059ab9b9aa74ae94aee50a09f75d6d840cc6a1ec48593aa2d629d9232fa18120bc1d41beaed6b9dd076a130a6027723a6498315fd02b90f146f5029addc59a9b2d843a540d319fa25be7b0f22dcd07a45a81390df399034806fdb5ccd502c2a0eb3f52f6421a42f120664b93bcf6bdf2f4ea305c915196f15eed33d6dd03f6b53922d9a51dacbc19aad584d2fec06c5798ddcb710fb6bb258a9c25a7dfec7d3f10652df7aafbe9987f5f89ebde4a95a8a8dc1cd226a6ce79a277ce0840b5499ab880f3bc75fd9534ca80cd0aeb89e45dfad71a65be2b2710b45bc39bb4257f70c0d5fc9cb8cc98465d58ff52bd220ecd691a2e87b61ca77eb7f76cee22de19a469fc320a2eeea5ed54bad4c85594c203f7c45b8df247c3c6bdde183159c150e494d6dcf33efae02fa8d605c6470b746bd07406a72d02c02f35ad25ae0460f0729be6769cedfa664410593764c1072ba8a6f232dfb099652cf235f84ee7beb509a20f0e77f211c53c7a7c4f65afec65d3d67802d937898592229b26892412a82b8a8a41bd4ad16e0ef905ceb1383dd10bbf3ba2567c05a20b14ac42e47531c930318510a630eea0e03b4a5de2fb73608346f3886a47db0a5ae482b004108d71870e45673e888fe4cc713a6b0674791c1168d4b58cfc7b2d759081fb6cec20a399d740b3342cbabf433aac7267a57460440fed3874d53311a789dbe5a23882dbc2d027feba329247c7bff89633a58a9cb4c31c1cad758a42e6983a37b1d0bc53f8a9b7115c5b55f85b9a617db24f2d57089bc73a9ef09e2dcda8aa596d592d1ca02a7674d4d1a4f00c724eda612b82074728d6c972915691f6a2d6e55e225bbdaebcefd01308a00332bde18c2500198d8c33bc2e9baa29ceff01784b6d5305f4f394d3ff14a64d3070a9f3ba1a7c47edcc52d5964360a05ce79966dc2e84e7c2758b4f0c033dbff4e061b9de70d2f571e798cbec657ac56bfad9145b3932b2f4627d2ffec56c7172abcd347dce183ee2c7ce483f71274fed1590f9d9f0806f64b6d9a1a9b1e6ad60e41ba8ef23307683a99c44cf775e1ccf12bbd462267947c5626233a2563f42d932d58ab8a7bb15c0686c24e853e4295528888e48d3cbd5e7091cd6e403cbfe2a3a46ed41e3cc78fabc516916fe9d1ca445604df36afe61d4706bfb7bce3c6f88aa02f7f43ccc6d0062056d8684296f10ebb15e5cf6f9f5a023ea00fc347ac9261da5f8936819facc8e98ef6148525a608695b92fba90b3a54e65829536f3b390ccb3dbac529b4d03a5c12eeaf4a732a3a6379a6d105c8b59435ec2f945b320beb8031cd4bbdfa14249f4cedd636895558e649a3bb83b4bd7c6b6d439846d6b83f6417d665fc1d35f54f83e4c677c1fbbc0edb5ea41a780a3ef21c89301bc7ca69b8ee90d2a22126677b7336cfd907e610590f26d70796595d5f6aabaf9982e3fab817c06fc55b0ef35aedac2c653ea8b78932021740a29cde39afa3f4d67d022049d848bca3ca14c7d26a0b352813f8b9406e0d9d06dbddea464583311567a9ce21a66f215eccd04317ab9e48efb8a2bee89b7baabee4fafe3b7e5c8b4225379dd68c92c6e7630ce356b2dafc9096a5c696c73cda49769f1e4dd51053b1ca489d72ab61f5a312c69aca75e1c8be29ee22f11d0ae5c565f86831297cb7fc34577f4fddfc4d491448e9f354e09886f31eabe33ea2630b84258a911d2cd4e9234845d64ed42cb801c4af12e7e56cfcb8d1f59ee842d5331a9ad6265945206059d13e1c07a58cbbdb029431e7155ed6c9bc64bc7afd2eca98acf0c05b122f2615148fdefd5f93522c705478da89e29ca7b5dcc029c772a90e0a4957a2044484d39e0c23ed7d3c2bc07b595eb5a5e4e2947aaf1e1b6f40f3e98a45d2adf4f9e4e42ed516bfb127ae5417991320e4efcb8dffd0faf29d16d56b6f2081f079a39192033aaad32659a238e6df37825e2fa11dd8141ca45f9931a97b7617241b51a92cd9a787ac96f2dbf63cdf35d521ade8dc80bbd606946181ed55e3e5604bf8786b99d0d24386148cf5c8a889ab3a24017e832c5b1c9f04a6cff2483972624e9ff1b7e200e2f6b92d6fc92b534f3a2bd7d1a836695cb794aaec29ceb2c0b3a3b3eaaf15322f773fa740d9ec695ca9ab1b65ca5dea8d30898adfd8b2828b99b3692106ec9d8e8026f0d27149da7cdb910337cc3f0aa2a89233d920fc1a9745a9f66971520886d91ad7786c81877a2026b072a84b5d53d7b08dcca66e92cf0169b36b463dd2656d9c4ce09944cadd99f8c4479f8ee4fe1f183153db745c01a57ef6099efa1752ad092822ce1b2ce498f519713e03b6deadd6dbf2a94a53b8f8ac0539b3ce3dd6c54e069d61c7989c074e33c9ba16a5d4d081a164b48de9abd56dfeb86c136985827d34c1410ba9996eecfd29456c94f0d49c922bb484938e7eb94be2cd18b4468fd99a0809865f9a855a5a62ee4e99f7c9736fe642710bac636295c4513647b1690d5003e1cd1b7710da70d6a7ac20c5d206baef3d0f17771d40aff2eeeec8c0c38530ae45fd124bf5aea7cc6a8b365d50f48b04003161d520af5d8eaeac2abd9169faa1e496df0e39afb2503f87ca9f63e8c66b1bacfeaa5e93f5c435a698d1e24d727bcfff7edf884b7cbabae9e3c014a7a3938f67de336b3c9cb8ae72d2a79f6e158d6f779c9fc02ecfadc473213972cac26005a45893efe0104672e4c54eca0e836133c36c6a727c711d159657a30499bc2a971f2b09e91e4496ada208427612462ce7b0e35e757a9d2ae753216810be16bb3ea04a9182057c5db512e1af09664d3423ef6bea1a896d912f4ff79c636e180dc9ce22a6c34c1bd7b71f809847c3cdcba4cac920f6449876cbf82f0de0ade895b9d666a7a4efd1d15ce4ff7f61e193ba1673808a0e90923b991f3304b61d63436972beb8e0477702273dbfd86805be76f0b19fcb3a039cf55d5a42e8d93ca24cac0ad64d32d06769a8950f9c72a6db13bf6c30104fac95f582803b10f13561d4d56ba3f44d8eb236a78ed22accb20c7142bdfc8fe48506a2af480a78733b4e632ee2b9e3a001052d24dadc5fec6576c52feda91d92547106d46169088b2c066bba165f9ac1dff4c22c9599dfe806d30abd9d195cf0185a9bfadb6c7da295947ac6bfdee08b15841b3d70107e0eea7e061c031340d2806cd307072617240a4ef754c26367cefbc22719c1b14297b4dac7282da71f0cd03a20d17fe7d7b32403464664730462c199ab093faaebf47327658184818a9e74a5f817b707b2f61f83dec1e2a6d80e84d41ca971425c0ace6c767eafa2a1065d13462bb6b247eda979d5701968958ab26ef5652e059bee622cf886d9ac0011bcd427ca4ec8698f0e948fc85366188cc3bf1be1487de6acf3e0dce24095e5263f87adae83ded5be61605cbfeef90d29a79d7b141aa474ce9d2e2ca1d19a06d5cb280c1e6ca466ad4701f7971c17da7fec29e4ca3d153d0214db4220a236528078d3fda27e23ae0949be2b76df9ed937d2ef2b7d436c4ad630992402330132948ac14831c9185ce73a99785f586a660d30e82b14beafff5fd9d6c9f16936e6e13777edb937f4e95c9ae56e4d154c0f19ce5e8129472d12d879aef8e50b690a461776c89b0a27b8547488510de620b401e515ac376fd276eed6bb77faf6dadd4c9b2ac2d2c1dc65aec2480b7adddd83d254e515a2afe421a2dddfcf27c1e17fb4477b459313209781e66cede9d5c8755bb72d2f9036a52c93b690b49be3889e29d8e04759336889c85d2bc5e03989f8c28996c98498bdaef3b388822652c90ef93e7d517a1f3641da5a1c9c4c405c7660f7a00ea46347a6103bbed4aa138fc9009592b265375dfc7e0c7e76be1db6888fbee1b4b067383b92698fec1f9e19496bf9c8048e326ec5f3d98a8d73e015870974daf47494a92371c8456b58ce555851b7b19666d91f7ca940fd535e7e592ed13e43fe6276348faaef3c6e4099512da8496b1316193ed4834272f3a5908fc8f23ed10d101b1825385a7d570fe56cff9a352a45881e1f1cf8b50fe43228ba22ea73b1cd508afeb0faa4aa8106b728a4495abb14de05ffbeda1a47879491eb179ec9dd2ac6baab68927a137560c00d824728e5e5591301b2da613578214e3fc43f369ffe7747fb740bd91fbb61a4f0df9ba9a2e5b1d8eca0b26cc947e914d6ebae00d1b4d86fb4aa692bce8fbe3e91c0c203b40d9218815947f588d6ca0b270669db9dfd6f6abbede1ea33be5f5d6736fb95d4730ae7f3f485e23a2d0b3637397062a47fb8b2919f1455e3f2a721ae5b9e638aac1a2cb3500df0758272ba9a2858c005d076ebbc7cee4bee2152120c06628fed13e6018b862d72bd23c8dab2c9665a5518d6725eebe565b391eec9ba21c529087586abe2174de34a1bce885b2081d6f856057d090fc35c632f9e8b5afd6a143c41b32ba0f93b496a50d0b347d6a170d6a7e98cd1895fba5a46f948efb39c3d36f0139d558cb445c4c619ff60d292acc0c7f47df1a03ae5069e32b5cf9ec7b4e1c58d7f9415c141a32599677a368bb612459fdc7f1dad2ba6f15df5b57180de6281ce7e04b0f57153bccec3df5d183f31b3f3b61b995037b795bb617e44c8f2ea7a281e98a7df685ca58a387d8f31ddc357e7ff3624add0af57167b1c3727a09be1e6f5cb5ccd8147ea372b257dcf5415a98d20dc5bd20ea416907fb5da1ae738565625c47a6aece12260a4bbde84f3af6f3a734d66ef94fc0fa1db8e930ea663a8160c51720489e3996fb6cb3731875b9a2a6420813fc7628af8531aa91f55598815dbc4c8fd304733c0f2e4f9436c5a1a1ccc97f8a89090907a2dad571457515157dbd6ae429f04898bdf481014a3950644afd0dac2d79577b93ccf0d2e966a5de129fa551cf24c29ca894ad849f51f59646efadd2c1bdd219ac0b9a9efdd0560d2763685fc51de722034d938d070cebed35ef58517198d8c8e750acb02501f84c2c8781bc179e704eed158581a4fd46340d178272147afd8117b9267170e64298d2bfef23b663391bb265cf5fac4ee5fb39e6a223e7ea9420d7d4a0a6c9899af476c666e1d1ff19b97845a68f7394a28b108c614135e8ac84ddb67207b7aad7ef93072499d63b8c387d297282c9d246733ba12f5b77dc6b12ec8b3d0fc6f6ac0eb0729c4e50e2c64bfb73720d48f58592e238686826ab8d585c31db70a8e9ee967f08f86b87ed9b30e5e36abcc49721caeec78b14a5dac5a43f9e45143a7ad2f07c479a96effbaf3f9bdc70c36a846cebd1abbd426256e5818cb4df4433ed96c33813359b9b265d5d7f5d33d3906ad2fe1bd4a765708ce4345fe8b647a998df58084b3fb97e3e40c2ab254c9ce05532698c4d36e777a3b23d3b54b7693c06acdcdc9c9fc3ad1800570ba2a99ecb912140ee19f90ebce3e840bb9047a87d3f9d16035f51f36579e1b3e7357e092eb674de1a51fc215737afc7bb94ebc8411bcdb65266943db64c00cc93c707c91b7377c14ca1977387daf1d387f0b022ece74b7b0b59f0fb924f932f51c5ae02749d5f350805470617b6f968aaa727a9775df3107639471ce590940664d01fed40a8f742e0303f7e2ecd629945c86f5885bf54e29974d953861f665270c08986c15603a707c05b23563a33701916064cc5177b09fdf86b403672589899e3b6abef3cb61d4753559175cfce9751d0cdc6e4fb0543ecbc388dc9a2a3047601077f05a1c89180a7c2046c1be4e85202ef4429209acc3f52be1472c681c8e1f42ef1115fb2d2e3165f98f708c7a0ace845b4e79225b64fb73bf3e82b4709c94ca686995ddf5dbcbefcd567a3538caf01a83b2cd9ea29e35cc01a67050a727fb922d9ec1c626b70352b7deb0afa2e59840e5267001d46374500be9d94c68f341efff14b5413dd663385b76a4743e17a71c6ded54d6058f3f9875e6808006e87aefd5e7d0fe79ce5a2e97ba003654e57c2a70917b9a88af125565fc7ad42151b17fdceab27caf223452bbc62bf255511c19ba5bf156c5a0c20b838315ddbfe5525c2299817566c7cc59815e4ba906cf5fe63cca61b3bc188699586ef1a660f37ef5d9faa7133e34fd38ddadccafe1e1acb9cfa74ae1d6aaa16e7f353d4388a933af5fac70016a40b155a23cb21503042f17cef17c1d9310d0716b66f1ab99748611761de741b0139d7d4722dc9267a9c1d9a818086498f9f912de7019942beff544bd660894e350ff3dd48edb96f466a6712a9c918cc4039aad9f1acc6d2cb9b6f64bc7e82a6abf2b6d22e1e9e5e9ef3e0e7d4417b84f60fa8d916984a7e97e9ba317318d6ac00d15a6e3e35896af4e20d77991408def865168011e5fbb3ff532fe6bc1cd08361087e6f52f9d71cae842968f036a20337e2c54fb94f6a8bd11995d663fcdf409a1a7ecc360eec65e82f2ce4444e5f7d1f13fc2a664cae963bb6d8c989287a8ba767ffb82beb83ce2a2ab39cca53ec129317ce98f235520f087339c9929aeb075bddfc3b0b6833f03a9e6b3630c3ca466db8562344aa6ab4f25bf1963d0419fa931d963d1477ef340b34540f10d63a0ccef625e62460529e0d77471222dd03e64235949d0fa6f7ab829422cf242f974ea725495569e208d58170a09dfaa781998ede4c6caf455fb668884d954c26ca142630a71a8563a1b13bf35c85c532753e9b8df65fdeae8d8c81073d0024da1ef2c2050318f3478c0a1b6610de73e6d5ff6d8e9251a748187d5aaf0912aeeaf7c45a8479c5e7ff0f79f9b427e05da6a318de9a537804d90602229997c562ce5b8b7c18d437b2053aa8c438460fe4e81feef70fd817a273f09f8cd74035958a3f66529d490b83c0e6133db9e2799428e0719674c00ef4567d987f4706d0810164b027b285c3bf72b8ad3a38c2cbaf4a1d0a547130812dc52d48748783e5142a61cfa8668d94e11b597334725906314e3fb84ff70bd023f7e451daa48d4bb38f3262ccf621c97d7cbc1ed48616f5a6a09d8fb4a69193721cd46432241e497e946694f39db38267be360bb0f69079dee0fd4b556efb46707e025fe308431ea1ccac3d1d3c14cdb8ebdbd75f55983cec10fd0ceb6a9b5111f1ee5fedc083beca89f53c986853dd0f186235d745deb15cd4fbb35916911c01a05f47b6f478d4283b7833d73a84995005c589b4919173c7cdd047291d20f9e415ffe95231e4b66c9d6df68576f4ac4aeefd91251d240872a33dc108615fe75349542fd0751b2e4bdaf1900523234d5faa6ba381a5243649328b9ff3c02d0dd97064bf4ec832acfdbb05b2bec5ce442729713b8b32dda8d91595a338acc4a485c1f8b5b83a38190d4004f727bdd855d9d9a6046df649ce9c5713dba370a0e24ab56bedc775182473e3fc1d3d206d5101500339449124d9f0fe01d9de2f7c0d17667e90b510de2d96fb6a8f2f389d725b63f6aca00dde73caec382bed1b4078f1769f845d9e0b3c479ed89e62058e4e0df1c58c889008c3f7b60cdc5d6f0a66d59dc2ccffc9554a7b55381f71a554471316ca9725a23335bb6f41eebdeba1f6273873afbfa0e181c2837576f84cd6531a9bd20baecb8fabe48832f11f0ca4ca212da9afd5aaee0ae09569f5a3d55551a6e65ef1e48126c8c75779e3d96f933dc39d4f7242d3e07577f79aacc2b82a5963c475ce341c64caed8db5ab29c5e700c948e4454fcadbe5dc0c1eb00d336549039ac7765c2a50192c7f801c4c947498186f427cd1e76b89c740933ab12c6482807a41e69cb8b3211780907ced08134106915921d24d52024fed11895f9dfc39688a07025d8604f33c43000954c93b518cc431ae16b5eab204a1bcbc402a7a7d60de6adbd76a0966c809561f2015cfb31f2c84e3015a31b27252d3af06386353b6835e366edb695066d4acb681f08b9492cf1e0de08369a0b4e7ac61dbb3a5b211c5f56bed8ac028691306e2297402fe06e040af6395cca0494c4c6fa8e4c198e95c94dedcd8651be67f64559902d226c01be3c289a0773b07fbd803308e0d01b95ead39d40b253d3051ca74f4a6ce612188da730b49290f3348b910cf921bed7f6ebb79e8ce7aeabe019448ae4e248688afdffeda6ec19830178e2d641b4fb6c03e1095b5af8c092eabd19b5432749786100d6920652422bc4e3c747d6bd3f057c18254b201d5f9df7865d5a7f46bf76f6f4f28472525ef7ecbf0284e44df7f5ea34729cacb7b8574afde527a9cfa62db3787f83c13a0b154c3fc225a0506d31bc43528421983109a597d3015e40111867f837bbcd891e43df7ed51e3a41f725763fdfc02549c5cd411cb05412b7aefa469faa7e9726b753f024f8eebfa1823029793a874bb8f1e920d8969710f9149876be82095bf31eedd56a78cb29bc1c7b9308555d9a6f5bd90d739208d421f1696b123de9dfedbdca765dfa7761d642252fb04fe221aacc830ba43fcf18e6f8d1adb14d5af31493b6f2f2d9ecc4dfa19f75b977d299ae9c0cfa1dff8123195d2ed60cdeba4f9cc21bbdb6286accc37a7d2638db8873de849caccbb65bb473f0da255973542e599dd5a54ef8ae866165a6423f7ff3bc030850a502cde6803963921194f4e18a2e1e44953e785eb1f412f0d7b5ee8228aa2dbd20677aec8c4e21aee46fc44c7ef48ccfca7de976779621c5d2820260e7f479b56fc1d55523325136855005ccb95eeb9b9edad91b07b607a05f5798901e0dcffa48f97ddd8e8534ad95d541b75f2497a235ad182032c9125a4c30f73c750df3a09d79ecf4ccacf9fb24d5baf44e50023d69fcb32544a938a3ae79d03843b6e87354acb7221f6235ca9c75b099c440465f4113ba11b2535bf452f4a41c5ab6b3478496f3675e6f60d43e73aa0ae0e40859ebe97ee5be960d7bab566c1d4aa3efbaa049739209e8e0064c851e0ffa59a9ca2c54ad6f713b6fa9c1f30480a1921993526ea8c848c1403a7e97c33d55b9ffdbb7d46e7b06e2f11f06d81bc2771ac498ffabde36f816ac3000e7dd7216744cab7d2a3f95e6314edf65e48701547e61b86cf6607bbf206def9bf4c8ec9de1463205b012118a3f801374edb3ee851d73a9581996d45c17b812e7881c0cfa3cc4074953d89099db8807560b2291aeaabb6e70826c554f318e2cc9391f3c1cc1d105580d967ade6d0e7144671b40810ed4ade18daf9218ec6c491ce4c3ad6df1238a2d95a10b5c66d2e551e09eec00c12ef0c36b075a7287a4cf4498a5afbf74ee81bbe70baa874c60029dcec15d39fbb3fed70b55e2ee7a478e0542f825c4a5bb7ab4ce75c9c6af4fb93a8f8d58e0c5e57219840f777a6b5b997cfd2e281e8198d97de2d4b657e94dcaaba2bb79cccfbb83c30779626edb42acf985b5ca40956157614c3b08b1b241c24a46a58acfbb6bc1348b9fbcfe1fd7777f67483d1e46bd4830e6d111d2091106b8f3545ba4dc4ffa57e9489ee0dd654fe17021c8ff507b973c4f914dc471425ca54e37cf607263f3b3cedc7c05ca9897c5bb947f0522f50606b7e878e5d5cba56f851e1b16a760834da5ea32e962fbfe80d1e526dd06e6e76ef1c8465a37afda4912906688da96f74641ed4441003a093e21006cdd3ed2e80f238083e4930ffb40240129bc4eadbd5c1a8afe513d337e82795c71791c5867e5daab93f3bfbff117ca5abb6a269c70dfe176cd0327ba718c38114046a7af3334ed1a3ddf90fdae1b677415dd493af9ddf079c950d84b5ee3f86966fbe10cb40005338d5fb8b63628a1fbc5bbd9355324b9dc88eb80290041b4ab02dd1c3d3a7429b10a7943408decbec373ae94a599adef29cce7611f40059d67b9da0f10365b2c67f82f17995b03a675ca37c5f574544e8fff14bf52353a44aa7c164af1a6b3f942f50ad67dcc4758f35944fa8300f4f92f7c914a0c39757585fd4ebf9370512fe560d9d70088a8ef314dbc3f69b41798f190103ebd42d3fe8c4b6eb67447e8d3eb947c9ea534ae3018fbffe69f86c20f226aeaeee534dcf1b591f5b1ae894ece254f87c11471bde6e4a0a76a43e414efc38f0dd703608d43fd3decc4a7105403f076c43a0c3044c56d3f02a269c15a01c8c7856720fec6da7c989608f5eca161e42759f92eb79c4ac724792daa3d5a7e9df1202e513002c022d014bc76e5beddb75fc232ad961f1c38f327c9fe4425d0732252fe470eea70a30303b167b6b02ebb9cb2ff3ac1b35bdf7dd5b5bbf6992b55ab4778316e37666b6a66cc843f3188d93ffaf65b923c17dd5e736263e002fef38c26ba75a9a983acfd092e36aecd3207b7b5f03b2aa4d5c0bbe2654fe3caadaa629b3a8139a0c38c334b69232be4c0c178f46f7d53283d41dadfa90b5d014cd33706de75290e4a245394aeadcd7e11252503d89db29c255b963aa76b9284164d3b2a899632c63372a0df3e2a801aa776dc61b67bbaf03ec4d8ae690a6341db8e1aa7493630bb75ae6db61e9899ce899df713a732b11d7773da2e9ff10fb86212772991a8c70c479ed3f176008f88f8df46f05c7d06e33c12b407d4829d91842c78067354199a418fede107386ea97fb4b8612b57419136d1494cfeee79bff5e5d10c3cac05329eed62769e686725e8a119441e65e8840cab98d08f5d4d628c960937e58c3eec453dd3cc81e0791fea45da1a2a11cf7e6a54b2ddfd4b16680272323ecffdafce9e563263a1e54bfefe76735bfc674374e96b6933f7a5893eca6c54e6ddf576fbc9e56e42e8041d7e3468609ef32779fc835b0a6421389de08fb06c7ef1a5e6cf5aadbbe9f1ed3047b2d934211d42dfdf08397f374851ab829650eb90207c5d5045fe36671b892474618aa1525a46f2c88b8c3879797b8c45b5780f401cb84c3769718edc5778f354a37f22dcc100a529783be7131a0aa72ab4d8cfbd185c74695b6bc05ab630da6b59cb4e359118523ff697ec97edf3920e0f0ebba54c11bb953da6d55efa2dfdc07f0cca1d4e069e447689a112867a4937b52ffecbf69c6698a71029a41602c2968f72f220f066ae82bb1b9373e8bbb26712fa15a7fdcf3df22a2bbcede2aa74c399fdf4c552f25f0ad336adcaf7f41c5786ed6155550979ec1777ddd77c40df68e413581a338b586fa813394d3f39577ff383b9602e82dff134bccc7b7aafbce275845f4fd8acaa527d3d9296410b759acef860720877f9699c043c7dd120321530d7470789989be39cac6e9c58ac74d4dcd89b77364467b57bc956d85a0749639f0f2891dfc94a33e1354ecd7b7f2da1b29694ce496e6fc7d0d48b61228200846285d98715dfc96470fdc4b187c2535278c0d1fe621477877be2ba37bab34aab42ff32c5182ba207dc534dd74e374c0d63bde58dba75def72042c87670e0b54e85c45502e01bed61c73365016ee98126982374ba8d9c1d99eb224e04866431bff7a3681357a4a3ce2d7b25b91e7902e77cb5293e06be09e2716b8912b2c085eda86c1cb3122749554c34a90d8e5a7df9f180cd1681c5d8b284d0c6eebff31c769ac058ec4ec0360f2343d2734ce14343e98465d04900b6e2254bf2d13feaea19d6c8b534e254f86bd4aafab8314bc35d8239e9bbd1c5b488ae3b732aaa4b1c17b858f1963bf01a6fa82c329de62551f26387bc01334be6bfc00fc1fdbf4069e386efbdb9cb2c4f0704bdd0c04f96b54f3e60cb7f601fc15e10d1ff8ca61c32b0c65ac9a72019bbc1a7af4fd201db3816942849dfdc98ff7ed2b105161832ae33183ac579b319f59de44dbb80a3e8bc85be88274a4262a5fe7526f7c1b169092394027b564d6f47bc0c9c652e4bb1b0546b0512799cb82afa126e400c38acd7ca7649c182445f7b36f4189f78efb735281ac66013aafcfffdeeaa735d23db6b1dd6d3406deb1387fcdf1d5daaba336009e4d410bbe29b441e2b9dfa7e5817ff7ec75887bcae3506af842b7a0cf6fac23d4bb65eb196ca5f8d023e0194e58012ecaec9136d537b2caa9bb9c5c975a2653dc80728280cc266be5516e95aad6bbfbdf1ac685ec452a952c38db3fa29ffd3e8a2c1f02c5c9ec3c24fd714365daefefd76121cf6fb071beef2266e5bbad58da996dc0e11ff6925164c4851b71a137ad23e90021229ed3bf6b0bb5801971daa232669e8f50291eec3d88e7e5c64624f927de27cda50d82cb96e8046dec24b8f31d2b60849294a4d71119bea74dfe42c63b66407dd8b00b030dbb15626ef2c8faf979927a08aecc4545a44a13acc79d5e82a9b8eb17c1830431c6f60864b197f360b872e16346deefbac08005732e6b420cc3364f42539795f71bf11acfa9e44163f24596985aabb9696812c9edc8aa10cb4358f5a80dda3081e5a45352e7ca39116ed8aa69675e77bfc6269ecec669b3333155be7ab8305c69c000629f8d45600bda7b4104648d854c1dd40170e88a6f189eb3e06f78aca6688e4f5f82fe73e2a35cc43a69cfadd99da2a13987b938e8299a6ed57fdf04880954fc0eb44d8c045d780de7056fd5c2071972680a611f0c8346228698d26e42adbe3f44526c2cad33477bcf5111d99feeb441f0a09480e52f80aa23fe3cf25792d85af997be02c6203c9483138e11564bfd48058b75f3229af115b34b623116c21b7937921809ed518b3921564e4e690f46d19021f6d772cd0f3548cdc1a430b18116414b6677a934d839ed6bc49ed6a976a3d043c3bb1011ba9d47b05163bb722e6861d1bf521544b67088cb56128cfca92a4ae0d7fa8af8caf63082ad325ce55627217a9444ad663d80f4184b103efd259f57e50b4edd5f9abbc9938c3e664ea587238795478ac70f990aaf960c3b202c92e831f745ccfc5cd1b7d1c5f252be55d387f74e5fff1d9b3df62a91b3b550bbb0cd49ae6ca610c3751888bc95d8e641e2d4ad6ce2d56e46ab73d05998aae81e429c6268e25a3b1a97964b839693d49fe08d0951dfa686970ed720ee2c2e3e9911156e4c9a0ebb7691f895ba0b666ea7d857a2a4e2f1ca659b59229281ed6e2f5096ee11f40514645ff37ae7441ae1cfe0d6ce105e2549e2b894062f14afa8c837eb8410f0cd3d8f85e11b76f817d2e1b6c3517313b7464dda149afce01bf1eb5248cd46d3feaf52c405dff3794ead634c8db1c9e724d77016004ed73b65174760657c16f3d6d7e9c9b04a9318f1e8ccbd8a7d8c1ca75a7c9746e652ee5eefbd258c4a778e53d288ea66745ee6f17138dfd394efb633dcb86176dab52c3ac8dfd59700128f6b3b125b9fdc9a9d469de93a5048102c27fe864715dd161b4eaede7523964ff205eaa07d32840e7739d60e5e9eb667116149f73a2864e08494c2853fed5853ebfc59e72227bb565e9d962258f552a74f82520e29757edb9d3ce2f3c90b4bf32548f5908068471e1b2ee93a70cfcdbc5f813c25023b4283a95e52a68e0e45a1e6dd91cd209bb193552686f92cbea41aa87c8de16e56e51e63d04e65f10077b55e01ead3d081018e46a4f5d963f57fab22e2be4e9539165f06971d29f3aaa5814be96f41287fb765d4ad1d9c46b42729ed28ca736a8468b603212407f90219f40c44e71d37bf946513421cecfbe23e1e6b0d462e8cb749800e525ef0e711b9e692b0a2b64d8e5225eff022465799897113265071ada97d8f7dcfb046b656b33eab594e9c8ddbb5b6981cb9c106a869a7b3cc2ab0b18c13828687e545b1cfa46e844c88b55d8ee7602526e9f38f9dcad4ab0964afe3742924b72fbfe5d530d492418b9361eed372656fa8ffb425c04972eca1c84d782b307eb978709e7c3bf4155d33135cf058120dd54b5e11b6d71a9125d0ba650f4738fdfe71205e72ae60fade9981918f82ade982298ea87aaafd2629f9b003fe61ff574bdbf24b2e532b16b1642d0e8dfa926b65d70da15ba19df86b2a8b06df92e522b2a137545990c18bacb65dec6cd8cfdefff17ec3d5a7d16d72367d3270456d3c1c4770d574e0960d4ce6a62ee8fdd88012354bc8e7eb901d22193a97fb2c4c2e3ca1efb171fc7246377fdb3f0b8ed3dd888212ea41008be83cba161d2de28f7c30bf92af88152faa4e92b41067d21ee8bbd67cbc2d8699136aa5069276c796144c86ba3dcf1065e1af8597aad4e4de74fba21bdbd969d7a2631d43dd477b5f461d746d4cd3b11b51d27f4824a107888a2e37c8801f3f26d2503109b94be4047e52b00c33c762b8c5b37570684b91ec1ab716682901cea7ad7ffb1d65c4c15cc07f90f25a878cb849165e96beb863d8e81dde8252515e3ce4d2efad70301454d6b4ee657e4f70cbbcf351ebf92ad460a47731237cb8d5e10d13d4931a89953028820f0402fa70673cc3dfb7605d7f4d26bd212e0e96d3c9a3f4fd98ee79b2b67751b7d8b6ee55653316963104cc978fc50c2f4431236f49c1113f6f4b399886e523fe7f36e7db69ffb78b8db7c7ae5dbec8397173026a44d89730c505b8b0faf76c8eac324c99eff941b83778fca13149ea130d09e61e9146ea1cc5e276c8ab22c978f71804563017114670025fe7c6cc2be8c391b71fb9f9a3a8002c953fae2d827fc7367e4db4dcbdd99e1c0ecfe35ed4b089c003516bdced100a777a7d6352ab5f365c406c5103ad13d4ea285ad396c431803ccc2e2994a696fc84bad6eb6c6aa5422a4557fd9a1174a2f4ff6641a4b2ac382199d2eeefe7fb1a42ccad086e8a8eae3a4f1270c07e23837d6dd476f2ad8ba3e0fb5fac5eb0e899b78aeb0b3686e20a96a91715536753a2a7d2489142e5104aa2a4068c41469fd1ecfc45f96e2632cbf2b7936eed45af1b7abc9af9942f849f42db5cfbc478d7e5d02a46c1105d67385a92a5377f8d4e341ce9a448995aa1fde63c5f9d8579bfc9ec8f18b74dde81ed902b6de11be31a25cefb9950eb8fc42a2e5f94fd2d9cb71b0678fd6f67314c09a240959d1796dfd505df0b1a91f40597f74030d2e7a3733ff11340b40d9dfa1c0ee45972881a615863d4ddca75fdeb8697c518dc0a78be8875dc9ceb298a48cf51daa8fee764236c0d675aecaa31a9044e028e16f1540c243d4f70ef0fa7da7b6d4a4121286945ff1288a976518299a326ca3d8ca2b4585d2c970fbf6fc9916b9f9caab70157d25bdd557cd3b71624aa0a1ee43b3f4e2f5ca13e06edb002682f852df24b174e2386de5485d1fe89e196dfbae0a309bdf23c2608bb8d4f789fd8d5f554811188821893023e740569c131b011b86c6f9f8c21b912e812b733b9c5d196d0556a4aedb184f939ee9468573f4a8ef2d487dac46e6c2c34a207d0855b93232d4d009260d265e9f7bfa4c03d67a3bf2103f2a1bcfeacc5d3fa37f60de6e2274fe0ff774554f8ecce2b7d69a520cdd4a286561450dbe2086ea16c84f5216caaadcc48036a4ae3514bd7a419e2676b43f5cf38bf73389c9e6490ab240bfd8e82071586d63dcbd97fef848877f1dddab0aa042e64c0c85d34f0d03af6d69b1ef5b51a661257dfec9b3b884c1fab1d317508900fd900d15b8a3df223cf10fa665c938475c4d4f3b060142d9a5abf7c6a04e0342d8d8fcd1ed602725caa9423e7a799b8707fb39cbc6d333cb6baea347844b860a44ea201bd9fa96a6f9f96bd9dde3fece318cbca988fbeddb3beb4dfd73b43fa69f4f18c6a042f6fe9e5b8762b0c318378433539694b252742b67426b2727dd94fe5078d5c48da3bf7f4d81bf21f700cc8ba096515222fe36275165a38316efa20ae11738734ac8925fa148cac5672bf3abb7d7caf4b15c00c376a6c134b0a2932676a073925f839c218388c29e2f50943902dcf7c726bbea15fe97fd79088015b798e5edecce1933fc65f5c3a2cde1fa6f98f46e1af00e13900030e3cca981cee373b9f30fd6836607515f9293f72008f312ceb92d257a4ae76286f6c5e5030f78f04292b88ee5eb1adba482f40a0b562b34d09d8843b86b5aa70c5cce1e5c8d74643f120474a61cb560a6f94732abec4849f5b000b7abb860617d547bd624ad77fda6cb3a9d3d8e20575ec429677bba323441457719adc6cb483e982c6cfaa15c708a5030f02ef300e0f918bf5fcbf3d1ac078ee00786ee6357f55ef67020773264a722226359590fa94c9930bb0c249b60005b0668bbb9cc50fe035865a7254084ac92510a745fced89c7bac2fd72dea327fb326e987186e5e0467b4aeac8fa9b624992e523039992bd0c9accd338a24b5d6f6a9ff33945dcdd9919fe91734b03ad42ef002f96348e61165264599f59330447c57d65fa679090f8772dbb193edf9cc3629775beb3c1d361d4d92946a145d94c74c1e248596267d761585af630885c8ef9c518044c16d9e49aac2a1c67d310c9262ea7b038ec95c072b3ab06360d688354b68364f65b697c5982b5b4b409aa91c960fcae9dfdfbadac7cada5eead7b485107be885457c7e5e55c7b8a8b330f7b3fa06ab100135c16747fd9bf425cd2460c7941cd9e71bc9699753550694667b602a072cbd5332d1e9201c68b4d4daa9f62c7bda8dc1cf6a052203c113cdfa81e9accb1d17014fd73cfb026c01</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>FZU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树说明</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？"><a href="#已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？" class="headerlink" title="已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？"></a>已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历？</h2><p>对一棵二叉树进行遍历，我们可以采取3中顺序进行遍历，分别是前序遍历、中序遍历和后序遍历。这三种方式是以访问父节点的顺序来进行命名的。假设父节点是N，左节点是L，右节点是R，那么对应的访问遍历顺序如下：</p>
<p>前序遍历    N－&gt;L－&gt;R<br>中序遍历    L－&gt;N－&gt;R<br>后序遍历    L－&gt;R－&gt;N</p>
<p>所以，对于以下这棵树，三种遍历方式的结果是：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1d5be45e572fa0202cdd7b2dd73afb1.png" alt="img"></p>
<ul>
<li>前序遍历    ABCDEF</li>
<li>中序遍历    CBDAEF</li>
<li>后序遍历    CDBFEA</li>
</ul>
<h2 id="已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历"><a href="#已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历" class="headerlink" title="已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历"></a>已知二叉树的前序遍历和中序遍历，如何得到它的后序遍历</h2><p>+++</p>
<p>其实，只要知道其中任意两种遍历的顺序，我们就可以推断出剩下的一种遍历方式的顺序，这里我们只是以：知道前序遍历和中序遍历，推断后序遍历作为例子，其他组合方式原理是一样的。要完成这个任务，我们首先要利用以下几个特性：</p>
<ul>
<li><p>特性A，对于前序遍历，第一个肯定是根节点；</p>
</li>
<li><p>特性B，对于后序遍历，最后一个肯定是根节点；</p>
</li>
<li><p>特性C，利用前序或后序遍历，确定根节点，在中序遍历中，根节点的两边就可以分出左子树和右子树；</p>
</li>
<li><p>特性D，对左子树和右子树分别做前面3点的分析和拆分，相当于做递归，我们就可以重建出完整的二叉树；</p>
</li>
</ul>
<p>我们以一个例子做一下这个过程，假设：</p>
<ul>
<li>前序遍历的顺序是: CABGHEDF</li>
<li>中序遍历的顺序是: GBHACDEF</li>
</ul>
<p>第一步，我们根据特性A，可以得知根节点是C，然后，根据特性C，我们知道左子树是：GHBA，右子树是：DEF。</p>
<pre><code>                     C
                  /     \
                GBHA    DEF
</code></pre><p>第二步，取出左子树，左子树的前序遍历是：ABGH，中序遍历是：GBHA，根据特性A和C，得出左子树的父节点是A，并且A没有右子树。</p>
<pre><code>                     C
                   /   \
                 A      DEF
                /
              GBH
</code></pre><p>第三步，使用同样的方法，前序是BGH，中序是GBH，得出父节点是B，G和H分别是左右节点。</p>
<pre><code>                  C
                /   \
               A     DEF
              /
             B
           /   \
         G       H
</code></pre><p>第四步，回到右子树，它的前序是EDF，中序是DEF，依然根据特性A和C，得出父节点是E，左右节点是D和F。</p>
<pre><code>                    C
                  /   \
                 A     E
                /     /  \
               B     D    F
             /  \
            G    H
</code></pre><p>到此，我们得到了这棵完整的二叉树，因此，它的后序遍历就是：GHBADFEC。</p>
<p>因此我们按照上面的思路，采用递归的方法建树即可完成，下面给出代码，并有例题，有兴趣者可以去试试！</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="7-1-小明的账单"><a href="#7-1-小明的账单" class="headerlink" title="7-1 小明的账单"></a>7-1 小明的账单</h3><p>Background<br>Special for beginners, ^_^</p>
<p>Description<br>小明在一次聚会中，不慎遗失了自己的钱包，在接下来的日子，面对小明的将是一系列的补卡手续和堆积的账单。。。</p>
<p>在小明的百般恳求下，老板最终同意延缓账单的支付时间。可老板又提出，必须从目前还没有支付的所有账单中选出面额最大和最小的两张，并把他们付清。还没有支付的账单会被保留到下一天。</p>
<p>请你帮他计算出支付的顺序。</p>
<p>Format<br>Input<br>第 1 行：一个正整数 N(N≤15,000)，表示小明补办银联卡总共的天数。</p>
<p>第 2 行到第 N+1 行：每一行描述一天中收到的帐单。先是一个非负整数 M≤100，表示当天收到的账单数，后跟 M 个正整数（都小于 1,000,000,000），表示每张帐单的面额。</p>
<p>输入数据保证每天都可以支付两张帐单。</p>
<p>Output<br>输出共 N 行，每行两个用空格分隔的整数，分别表示当天支付的面额最小和最大的支票的面额。</p>
<p>Samples<br>样例输入1<br>4<br>3 3 6 5<br>2 8 2<br>3 7 1 7<br>0<br>样例输出1<br>3 6<br>2 8<br>1 7<br>5 7<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int id=0;</span><br><span class="line">bool vis[3000005];//账单是否已还清</span><br><span class="line">struct node &#123;//账单</span><br><span class="line">    int id;//账单编号</span><br><span class="line">    int num;//账单金额</span><br><span class="line">&#125;;</span><br><span class="line">struct big&#123;//大根堆比较仿函数</span><br><span class="line">    bool operator() (const node x,const node y)&#123;</span><br><span class="line">        return x.num&lt;y.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct samll&#123;//小根堆比较仿函数</span><br><span class="line">    bool operator() (const node x,const node y)&#123;</span><br><span class="line">        return x.num&gt;y.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;node,vector&lt;node&gt;,big&gt; qd;//大根堆</span><br><span class="line">priority_queue &lt;node,vector&lt;node&gt;,samll&gt; qx;//小根堆</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i=1;i&lt;=n;i++)&#123;//n天</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)&#123;//每天m个账单</span><br><span class="line">            int x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            id++;//编号</span><br><span class="line">            node t;</span><br><span class="line">            t.id=id;</span><br><span class="line">            t.num=x;</span><br><span class="line">            qd.push(t);//大根堆入堆</span><br><span class="line">            qx.push(t);//小根堆入堆</span><br><span class="line">        &#125;</span><br><span class="line">        while(vis[qx.top().id]==true)&#123;//把小根堆中付过的账单剔除</span><br><span class="line">            qx.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while(vis[qd.top().id]==true)&#123;//把大根堆中付过的账单剔除</span><br><span class="line">            qd.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;qx.top().num&lt;&lt;&quot; &quot;&lt;&lt;qd.top().num&lt;&lt;&quot;\n&quot;;//输出当前最小账单和最大账单</span><br><span class="line">        vis[qx.top().id]=true;//标记当前小根堆账单已付</span><br><span class="line">        vis[qd.top().id]=true;//标记当前大根堆账单已付</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-Windows消息队列"><a href="#7-2-Windows消息队列" class="headerlink" title="7-2 Windows消息队列"></a>7-2 Windows消息队列</h3><p>消息队列是 Windows 系统的基础。对于每个进程，系统维护一个消息队列。如果在进程中有特定事件发生，如点击鼠标、文字改变等，系统将把这个消息连同表示此消息优先级高低的正整数（称为优先级值）加到队列当中。同时，如果队列不是空的，这一进程循环地从队列中按照优先级获取消息。请注意优先级值低意味着优先级高。请编辑程序模拟消息队列，将消息加到队列中以及从队列中获取消息。</p>
<p>输入格式:<br>输入第 1 行给出正整数 n（≤10<br>5<br> ），随后 n 行，每行给出一个指令——GET 或 PUT，分别表示从队列中取出消息或将消息添加到队列中。如果指令是 PUT，后面就有一个消息名称、以及一个正整数表示消息的优先级，此数越小表示优先级越高。消息名称是长度不超过 10 个字符且不含空格的字符串；题目保证队列中消息的优先级无重复，且输入至少有一个 GET。</p>
<p>输出格式:<br>对于每个 GET 指令，在一行中输出消息队列中优先级最高的消息的名称和参数。如果消息队列中没有消息，输出 EMPTY QUEUE!。对于 PUT 指令则没有输出。</p>
<p>输入样例:<br>9<br>PUT msg1 5<br>PUT msg2 4<br>GET<br>PUT msg3 2<br>PUT msg4 4<br>GET<br>GET<br>GET<br>GET<br>输出样例:<br>msg2<br>msg3<br>msg4<br>msg1<br>EMPTY QUEUE!<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	char message[11];</span><br><span class="line">	int rank;</span><br><span class="line">	friend bool operator&lt;(node a, node b) &#123;</span><br><span class="line">		return a.rank &gt; b.rank;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;//有序队列，按数字进行从大到小排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	string op;</span><br><span class="line">	node p;</span><br><span class="line">	int n;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		if (op[0] == &#x27;P&#x27;) &#123;</span><br><span class="line">			cin &gt;&gt; p.message &gt;&gt; p.rank;</span><br><span class="line">			q.push(p);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(op[0] == &#x27;G&#x27;) &#123;</span><br><span class="line">			if (!q.empty()) &#123;</span><br><span class="line">				cout &lt;&lt; q.top().message &lt;&lt; endl;</span><br><span class="line">				q.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;EMPTY QUEUE!&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="7-1-旅游规划"><a href="#7-1-旅游规划" class="headerlink" title="7-1 旅游规划"></a>7-1 旅游规划</h3><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p>
<p>输入格式:<br>输入说明：输入数据的第 1 行给出 4 个正整数 n、m、s、d，其中 n（2≤n≤500）是城市的个数，顺便假设城市的编号为 0~(n−1)；m 是高速公路的条数；s 是出发地的城市编号；d 是目的地的城市编号。随后的 m 行中，每行给出一条高速公路的信息，分别是：城市 1、城市 2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过 500。输入保证解的存在。</p>
<p>输出格式:<br>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p>
<p>输入样例:<br>4 5 0 3<br>0 1 1 20<br>1 3 2 30<br>0 3 4 10<br>0 2 2 20<br>2 3 1 20<br>输出样例:<br>3 40<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">// 定义图中的边结构体，包含目标城市（to）、路径长度（length）和费用（cost）</span><br><span class="line">typedef struct Edge&#123;</span><br><span class="line">    int to;     // 目标城市</span><br><span class="line">    int length; // 从当前城市到目标城市的路径长度</span><br><span class="line">    int cost;   // 从当前城市到目标城市的费用</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义城市状态结构体，包含城市编号、路径长度（dist）和费用（fee）</span><br><span class="line">// 重载了 &gt; 运算符，使得优先队列能根据路径长度和费用优先排序</span><br><span class="line">typedef struct State&#123;</span><br><span class="line">    int city;  // 当前城市</span><br><span class="line">    int dist;  // 从起点到当前城市的路径长度</span><br><span class="line">    int fee;   // 从起点到当前城市的总费用</span><br><span class="line">    </span><br><span class="line">    // 重载大于运算符，首先按照路径长度升序排序，如果路径长度相同则按费用升序排序</span><br><span class="line">    bool operator&gt;(const State&amp; other) const &#123;</span><br><span class="line">        if (dist == other.dist) &#123;</span><br><span class="line">            return fee &gt; other.fee;  // 如果路径长度相同，选择费用较小的路径</span><br><span class="line">        &#125;</span><br><span class="line">        return dist &gt; other.dist;  // 否则选择路径长度较小的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int n, m, s, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;  // 输入城市数 n，道路数 m，起点 s 和终点 d</span><br><span class="line">    </span><br><span class="line">    // 使用邻接表表示图，保存每条边的信息，graph[i] 存储与城市 i 相关的所有边</span><br><span class="line">    vector&lt; vector&lt;Edge&gt; &gt; graph(n);</span><br><span class="line"></span><br><span class="line">    // 输入所有的边信息，构建图</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int u, v, length, cost;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; length &gt;&gt; cost;</span><br><span class="line">        // 无向图，双向保存每条边</span><br><span class="line">        graph[u].push_back(&#123;v, length, cost&#125;);</span><br><span class="line">        graph[v].push_back(&#123;u, length, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化 Dijkstra 算法所需的数据结构</span><br><span class="line">    vector&lt;int&gt; dist(n, INF); // dist[i] 存储从起点到城市 i 的最短路径长度</span><br><span class="line">    vector&lt;int&gt; fee(n, INF);  // fee[i] 存储从起点到城市 i 的最小费用</span><br><span class="line"></span><br><span class="line">    dist[s] = 0;  // 起点到起点的路径长度是 0</span><br><span class="line">    fee[s] = 0;   // 起点到起点的费用是 0</span><br><span class="line"></span><br><span class="line">    // 优先队列，用于选择当前最优的城市，按照 (路径长度, 费用) 升序排序</span><br><span class="line">    priority_queue&lt;State, vector&lt;State&gt;, greater&lt;State&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123;s, 0, 0&#125;);  // 将起点城市推入队列，初始路径长度和费用都是 0</span><br><span class="line"></span><br><span class="line">    // Dijkstra 算法主体部分</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        State current = pq.top();  // 获取队列中的当前最优城市</span><br><span class="line">        pq.pop();  // 从队列中移除当前城市</span><br><span class="line"></span><br><span class="line">        int u = current.city;  // 当前城市编号</span><br><span class="line"></span><br><span class="line">        // 如果当前城市的路径长度大于已经记录的最短路径长度，或者路径长度相同但费用较大，则跳过</span><br><span class="line">        if (current.dist &gt; dist[u] || (current.dist == dist[u] &amp;&amp; current.fee &gt; fee[u])) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历与当前城市相邻的所有城市</span><br><span class="line">        for (int i = 0; i &lt; graph[u].size(); i++) &#123;</span><br><span class="line">            const Edge&amp; edge = graph[u][i];  // 获取当前边的信息</span><br><span class="line"></span><br><span class="line">            int v = edge.to;              // 目标城市编号</span><br><span class="line">            int newDist = dist[u] + edge.length;  // 通过当前城市到达目标城市的新路径长度</span><br><span class="line">            int newFee = fee[u] + edge.cost;     // 通过当前城市到达目标城市的新费用</span><br><span class="line"></span><br><span class="line">            // 如果新路径长度比原路径长度短，或者路径长度相同但新费用较低，则更新路径信息</span><br><span class="line">            if (newDist &lt; dist[v] || (newDist == dist[v] &amp;&amp; newFee &lt; fee[v])) &#123;</span><br><span class="line">                dist[v] = newDist;  // 更新最短路径长度</span><br><span class="line">                fee[v] = newFee;    // 更新最小费用</span><br><span class="line">                pq.push(&#123;v, newDist, newFee&#125;);  // 将新的城市状态加入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出从起点到终点的最短路径长度和最小费用</span><br><span class="line">    cout &lt;&lt; dist[d] &lt;&lt; &quot; &quot; &lt;&lt; fee[d] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-最短路径-Dijkstra"><a href="#7-2-最短路径-Dijkstra" class="headerlink" title="7-2 最短路径-Dijkstra"></a>7-2 最短路径-Dijkstra</h3><p>城市的道路四通八达，我们经常需要查找从某地出发到其他地方的路径，当然我们希望能最快到达。现得到去每个地方需要花费的时间，现请你编写程序，计算从特定地点出发到所有城市之间的最短时间。</p>
<p>输入格式:<br>输入的第一行给出城市数目N (1≤N≤10)和道路数目M和1（表示有向图）或0（表示无向图）；</p>
<p>接下来的M行对应每个城市间来往所需时间，每行给出3个正整数，分别是两个城市的编号（从1编号到N）和来往两城市间所需时间。最后一行给出一个编号，表示从此编号地点出发。</p>
<p>输出格式:<br>输出从特定地点出发到达所有城市（按编号1-编号N顺序输出）的距离（用编号1-&gt;编号**: 表示 ），如果无路，请输出no path。每个城市占一行。</p>
<p>输入样例:<br>5 5 1<br>1 2 2<br>1 4 8<br>2 3 16<br>4 3 6<br>5 3 3<br>1<br>输出样例:<br>1-&gt;1:0<br>1-&gt;2:2<br>1-&gt;3:14<br>1-&gt;4:8<br>1-&gt;5:no path<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">// 定义结构体 Edge，表示图中的一条边，包含目标城市 city 和边的权重 time</span><br><span class="line">typedef struct Edge &#123;</span><br><span class="line">    int city, time;</span><br><span class="line">    // 重载大于运算符，使优先队列能够按时间升序排列</span><br><span class="line">    bool operator&gt;(const Edge&amp; e) const &#123;</span><br><span class="line">        return time &gt; e.time;  // 按照时间升序排列</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int N, M, flag;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; flag; // 输入城市数量 N, 道路数量 M 和图的类型标志 flag</span><br><span class="line"></span><br><span class="line">    // 邻接表存储图，adj[i] 代表与城市 i 相连的所有城市及相应的时间</span><br><span class="line">    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(N + 1);</span><br><span class="line"></span><br><span class="line">    // 输入所有的道路信息，构建图</span><br><span class="line">    for (int i = 0; i &lt; M; i++) &#123;</span><br><span class="line">        int u, v, time;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; time;  // 输入一条道路信息，城市 u 到城市 v 的时间为 time</span><br><span class="line">        adj[u].push_back(&#123; v, time &#125;); // 在城市 u 的邻接表中加入到城市 v 的边</span><br><span class="line">        if (!flag) &#123; // 如果是无向图，则需要将反向的道路添加进去</span><br><span class="line">            adj[v].push_back(&#123; u, time &#125;); // 在城市 v 的邻接表中加入到城市 u 的边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int start;</span><br><span class="line">    cin &gt;&gt; start; // 输入起始城市 start</span><br><span class="line"></span><br><span class="line">    // 初始化距离数组 dist，表示从起点到各个城市的最短时间，初始值为无穷大</span><br><span class="line">    vector&lt;int&gt; dist(N + 1, INF);</span><br><span class="line">    dist[start] = 0; // 起点到起点的时间是 0</span><br><span class="line"></span><br><span class="line">    // 优先队列，用来实现 Dijkstra 算法的贪心选择</span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123; start, 0 &#125;); // 将起点加入优先队列</span><br><span class="line"></span><br><span class="line">    // Dijkstra 算法主体部分</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        int u = pq.top().city; // 当前城市 u</span><br><span class="line">        int d = pq.top().time; // 当前城市 u 的最短时间</span><br><span class="line">        pq.pop();</span><br><span class="line"></span><br><span class="line">        // 如果当前时间已经大于之前记录的最短时间，说明这是一个过时的队列元素，可以跳过</span><br><span class="line">        if (d &gt; dist[u]) &#123; continue; &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历所有与当前城市 u 相邻的城市 v</span><br><span class="line">        for (int i = 0; i &lt; adj[u].size(); i++) &#123;</span><br><span class="line">            int v = adj[u][i].first; // 相邻城市 v</span><br><span class="line">            int time = adj[u][i].second; // 当前道路的时间</span><br><span class="line"></span><br><span class="line">            // 如果通过 u 这个城市到达 v 的时间更短，则更新 v 的最短时间</span><br><span class="line">            if (dist[u] + time &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + time;</span><br><span class="line">                pq.push(&#123; v, dist[v] &#125;); // 将更新后的城市 v 加入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出从起点到所有城市的最短时间</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        if (dist[i] == INF) &#123; // 如果某个城市不可达</span><br><span class="line">            cout &lt;&lt; start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; i &lt;&lt; &quot;:no path&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123; // 否则输出最短时间</span><br><span class="line">            cout &lt;&lt; start &lt;&lt; &quot;-&gt;&quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="7-3-图深度优先遍历"><a href="#7-3-图深度优先遍历" class="headerlink" title="7-3 图深度优先遍历"></a>7-3 图深度优先遍历</h3><p>编写程序对给定的有向图（不一定连通）进行深度优先遍历，图中包含n个顶点，编号为0至n-1。本题限定在深度优先遍历过程中，如果同时出现多个待访问的顶点，则优先选择编号最小的一个进行访问，以顶点0为遍历起点。</p>
<p>输入格式:<br>输入第一行为两个整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过50。接下来e行表示每条边的信息，每行为两个整数a、b，表示该边的端点编号，但各边并非按端点编号顺序排列。</p>
<p>输出格式:<br>输出为一行整数，每个整数后一个空格，即该有向图的深度优先遍历结点序列。</p>
<p>输入样例1:<br>3 3<br>0 1<br>1 2<br>0 2<br>输出样例1:<br>0 1 2<br>输入样例2:<br>4 4<br>0 2<br>0 1<br>1 2<br>3 0<br>输出样例2:<br>0 1 2 3<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，通常用来表示不可达或未初始化的值。</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; adj; // 邻接表，用来存储图的边。每个元素 adj[i] 存储与顶点 i 相邻的所有顶点。</span><br><span class="line">vector&lt;bool&gt; vis; // 用于标记每个顶点是否已被访问。</span><br><span class="line">vector&lt;int&gt; ans; // 存储DFS遍历的结果（遍历顺序）。</span><br><span class="line">int n, m; // n为顶点数，m为边数。</span><br><span class="line"></span><br><span class="line">// 深度优先遍历函数</span><br><span class="line">void dfs(int x) &#123;</span><br><span class="line">    ans.push_back(x);   // 访问当前节点，将其添加到答案列表</span><br><span class="line">    vis[x] = true;      // 标记当前节点为已访问</span><br><span class="line">    // 遍历当前节点的所有邻接节点</span><br><span class="line">    for (auto v : adj[x]) &#123;</span><br><span class="line">        if (!vis[v]) &#123;   // 如果该邻接节点未被访问</span><br><span class="line">            dfs(v);      // 递归访问该邻接节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭C++标准输入输出流的同步，提升性能。</span><br><span class="line">    cin.tie(0); // 解绑cin和cout，避免在输入时强制刷新输出，进一步提升性能。</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入图的顶点数 n 和边数 m。</span><br><span class="line">    adj.assign(n, &#123;&#125;); // 初始化邻接表，大小为n，每个元素是一个空的vector&lt;int&gt;。</span><br><span class="line">    vis.assign(n, false); // 初始化vis数组，标记所有顶点未访问。</span><br><span class="line"></span><br><span class="line">    // 读取每条边并更新邻接表</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; // 输入边 (u, v)，表示有一条从u到v的有向边。</span><br><span class="line">        adj[u].push_back(v); // 将v加入到u的邻接表中。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对每个顶点的邻接列表进行排序，确保深度优先遍历时访问编号最小的邻接点。</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        sort(adj[i].begin(), adj[i].end()); // 对邻接表中的每个列表进行排序。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历所有顶点，若某个顶点未被访问过，则从该顶点开始进行深度优先遍历。</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (!vis[i]) &#123; </span><br><span class="line">            dfs(i); // 从顶点i开始DFS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出DFS的遍历顺序。</span><br><span class="line">    for (auto x : ans) &#123; </span><br><span class="line">        cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 输出每个节点的遍历顺序，节点之间以空格分隔。</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; // 输出换行。</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="7-4-图的先广搜索"><a href="#7-4-图的先广搜索" class="headerlink" title="7-4 图的先广搜索"></a>7-4 图的先广搜索</h3><p>输出无向图的给定起点的先广序列。</p>
<p>输入格式:<br>输入第一行给出三个正整数，分别表示无向图的节点数N（1&lt;N≤10）、边数M（≤50）和探索起始节点编号S（节点从1到N编号）。</p>
<p>随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号。</p>
<p>输出格式:<br>输出从S开始的无向图的先广搜索序列（用编号表示每个节点），用一个空格隔开，最后也有一个空格；如果为非连通图，再在结尾处另起一行输出一个0，表示此图非连通。</p>
<p>由于广度优先遍历的节点序列是不唯一的，为了使得输出具有唯一的结果，我们约定以表头插入法构造邻接表。</p>
<p>输入样例:<br>6 8 2<br>1 2<br>2 3<br>3 4<br>4 5<br>5 6<br>6 4<br>3 6<br>1 5<br>输出样例:<br>2 3 1 6 4 5<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define fastio  ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line">const int N = 15;</span><br><span class="line">const int M = 55;</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to, nxt;</span><br><span class="line">&#125;edges[M&lt;&lt;1];</span><br><span class="line">int n, m, s, cnt, head[N];</span><br><span class="line">bool vis[N];</span><br><span class="line"></span><br><span class="line">void addEdge(int u, int v)&#123;</span><br><span class="line">    edges[++cnt] = Edge(&#123;v, head[u]&#125;);</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    fastio;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        addEdge(u, v);</span><br><span class="line">        addEdge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    que.push(s);</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        int x = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        ans.push_back(x);</span><br><span class="line">        for (int i = head[x]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            int to = edges[i].to;</span><br><span class="line">            if (!vis[to]) &#123;</span><br><span class="line">                vis[to] = true;</span><br><span class="line">                que.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto x : ans) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    if (ans.size() != n) &#123; cout &lt;&lt; 0; &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="7-1-选择法排序"><a href="#7-1-选择法排序" class="headerlink" title="7-1 选择法排序"></a>7-1 选择法排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-冒泡法排序"><a href="#7-2-冒泡法排序" class="headerlink" title="7-2 冒泡法排序"></a>7-2 冒泡法排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> K, count = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j<span class="number">+1</span>];</span><br><span class="line">                arr[j<span class="number">+1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == K) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-两个有序链表序列的合并"><a href="#7-3-两个有序链表序列的合并" class="headerlink" title="7-3 两个有序链表序列的合并"></a>7-3 两个有序链表序列的合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, x;</span><br><span class="line">    <span class="built_in">memset</span>(a, INF, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123; flag++; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; a[i++] = x; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a, a + i);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index) &#123; cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[j]; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            cout &lt;&lt; a[j]; </span><br><span class="line">            index = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!index) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-PAT排名汇总"><a href="#7-4-PAT排名汇总" class="headerlink" title="7-4 PAT排名汇总"></a>7-4 PAT排名汇总</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相同情况按学号排大小</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string id = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> exam = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> grade = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rank_all = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rank_exam = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> Student&amp; a, <span class="type">const</span> Student&amp; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.grade == b.grade) &#123; <span class="keyword">return</span> a.id &lt; b.id; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> a.grade &gt; b.grade; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Student&gt; all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        vector&lt;Student&gt; v;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            Student temp;</span><br><span class="line">            temp.exam = i;</span><br><span class="line">            cin &gt;&gt; temp.id &gt;&gt; temp.grade;</span><br><span class="line">            v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;Student&gt;());<span class="comment">//降序，默认升序</span></span><br><span class="line">        <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                v[j].rank_exam = rank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j].grade == v[j - <span class="number">1</span>].grade) &#123;</span><br><span class="line">                    v[j].rank_exam = rank;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    rank = j + <span class="number">1</span>;</span><br><span class="line">                    v[j].rank_exam = rank;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum += n;</span><br><span class="line">        all.<span class="built_in">insert</span>(all.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;Student&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            all[j].rank_all = rank;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (all[j].grade == all[j - <span class="number">1</span>].grade) &#123;</span><br><span class="line">                all[j].rank_all = rank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rank = j + <span class="number">1</span>;</span><br><span class="line">                all[j].rank_all = rank;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">        cout &lt;&lt; all[i].id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].rank_all &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].exam &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].rank_exam &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>含bug<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string id = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> exam = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> grade = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rank_all = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rank_exam = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> Student&amp; a, <span class="type">const</span> Student&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.grade &gt; b.grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Student&gt; all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        vector&lt;Student&gt; v;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            Student temp;</span><br><span class="line">            temp.exam = i;</span><br><span class="line">            cin &gt;&gt; temp.id &gt;&gt; temp.grade;</span><br><span class="line">            v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;Student&gt;());<span class="comment">//降序，默认升序</span></span><br><span class="line">        <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                v[j].rank_exam = rank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j].grade == v[j - <span class="number">1</span>].grade) &#123;</span><br><span class="line">                    v[j].rank_exam = rank;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    rank = j + <span class="number">1</span>;</span><br><span class="line">                    v[j].rank_exam = rank;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum += n;</span><br><span class="line">        all.<span class="built_in">insert</span>(all.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;Student&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; </span><br><span class="line">            all[j].rank_all = rank; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (all[j].grade == all[j - <span class="number">1</span>].grade) &#123;</span><br><span class="line">                all[j].rank_all = rank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rank = j + <span class="number">1</span>;</span><br><span class="line">                all[j].rank_all = rank;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">        cout &lt;&lt; all[i].id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].rank_all &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].exam &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; all[i].rank_exam &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试用例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">1</span><br><span class="line">1234567890001 100</span><br><span class="line">2</span><br><span class="line">1234567890002 99</span><br><span class="line">1234567890020 100</span><br><span class="line">2</span><br><span class="line">1234567890003 100</span><br><span class="line">1234567890033 98</span><br><span class="line">1</span><br><span class="line">1234567890004 97</span><br><span class="line">2</span><br><span class="line">1234567890005 96</span><br><span class="line">1234567890025 99</span><br><span class="line">1</span><br><span class="line">1234567890006 95</span><br><span class="line">1</span><br><span class="line">1234567890007 93</span><br><span class="line">3</span><br><span class="line">1234567890015 94</span><br><span class="line">1234567890016 91</span><br><span class="line">1234567890017 90</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="7-1-字典合并"><a href="#7-1-字典合并" class="headerlink" title="7-1 字典合并"></a>7-1 字典合并</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">// 声明处理字符串的函数</span><br><span class="line">void solve(string&amp; str);</span><br><span class="line"></span><br><span class="line">// 存储解析出的键值对</span><br><span class="line">vector&lt;pair&lt;int, string&gt;&gt; vd;</span><br><span class="line">// 存储键到值的映射</span><br><span class="line">unordered_map&lt;string, int&gt; m;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    string s1, s2; // 用于存储两行输入</span><br><span class="line">    getline(cin, s1); // 读取第一行</span><br><span class="line">    getline(cin, s2); // 读取第二行</span><br><span class="line"></span><br><span class="line">    solve(s1); // 解析第一行</span><br><span class="line">    solve(s2); // 解析第二行</span><br><span class="line"></span><br><span class="line">    // 按照 ASCII 值和字符串排序</span><br><span class="line">    sort(vd.begin(), vd.end());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;&#123;&quot;; // 输出开始的花括号</span><br><span class="line">    for (int i = 0; i &lt; vd.size(); i++) &#123;</span><br><span class="line">        string s = vd[i].second; // 获取当前元素的字符串</span><br><span class="line">        if (i &gt; 0) &#123; cout &lt;&lt; &quot;,&quot;; &#125; // 如果不是第一个元素，输出逗号</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; &quot;:&quot; &lt;&lt; m[s]; // 输出键和对应的值</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;&#125;&quot;; // 输出结束的花括号</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解析输入字符串</span><br><span class="line">void solve(string&amp; s) &#123;</span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++) &#123; // 遍历字符串中的每个字符</span><br><span class="line">        if (s[i] == &#x27;:&#x27;) &#123; // 找到键值对的分隔符 &#x27;:&#x27;</span><br><span class="line">            string str; // 用于存储键</span><br><span class="line">            int asc = 0; // 存储键的 ASCII 值</span><br><span class="line">            int sum = 0; // 存储值的总和</span><br><span class="line"></span><br><span class="line">            // 读取键值</span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                // 读取字符键</span><br><span class="line">                if (s[i - 1] == &#x27;&quot;&#x27;) &#123; // 如果键是字符串（被引号包围）</span><br><span class="line">                    str += &#x27;&quot;&#x27;; // 添加开头的引号</span><br><span class="line">                    str += s[i - 2]; // 添加字符</span><br><span class="line">                    str += &#x27;&quot;&#x27;; // 添加结尾的引号</span><br><span class="line">                    asc = static_cast&lt;int&gt;(s[i - 2]); // 获取字符的 ASCII 值</span><br><span class="line">                &#125;</span><br><span class="line">                // 读取数字键</span><br><span class="line">                else &#123;</span><br><span class="line">                    int j = i; // j 指向当前 &#x27;:&#x27; 的位置</span><br><span class="line">                    while (s[j - 1] != &#x27;,&#x27; &amp;&amp; s[j - 1] != &#x27;&#123;&#x27;) &#123; // 向前找到数字的开始</span><br><span class="line">                        str += s[j - 1]; // 逐个添加字符</span><br><span class="line">                        j--; // 向前移动</span><br><span class="line">                    &#125;</span><br><span class="line">                    reverse(str.begin(), str.end()); // 反转字符串，获取正确的数字表示</span><br><span class="line">                    asc = stoi(str); // 将字符串转换为整数</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 读取值</span><br><span class="line">                i++; // 移动到值的开始</span><br><span class="line">                while (i &lt; s.size() &amp;&amp; s[i] != &#x27;,&#x27; &amp;&amp; s[i] != &#x27;&#125;&#x27;) &#123; // 读取直到遇到分隔符</span><br><span class="line">                    if (isdigit(s[i])) &#123; // 如果当前字符是数字</span><br><span class="line">                        sum = sum * 10 + (s[i] - &#x27;0&#x27;); // 更新值</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++; // 移动到下一个字符</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 更新映射</span><br><span class="line">                if (m[str]) &#123; // 如果键已经存在</span><br><span class="line">                    m[str] += sum; // 累加值</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    vd.push_back(&#123; asc, str &#125;); // 否则，添加新的键值对</span><br><span class="line">                    m[str] = sum; // 初始化键的值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-2-这是二叉搜索树吗？"><a href="#7-2-这是二叉搜索树吗？" class="headerlink" title="7-2 这是二叉搜索树吗？"></a>7-2 这是二叉搜索树吗？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	int val;</span><br><span class="line">	node* lchild, * rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void build(node* &amp;T, int data) &#123;</span><br><span class="line">	if(T == NULL) &#123;</span><br><span class="line">		T = new node; </span><br><span class="line">		T-&gt;val = data;</span><br><span class="line">		T-&gt;lchild = T-&gt;rchild = NULL;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if (data &lt; T-&gt;val) &#123; build(T-&gt;lchild, data); &#125;</span><br><span class="line">	else &#123; build(T-&gt;rchild, data); &#125;</span><br><span class="line">&#125;</span><br><span class="line">//前序遍历二叉树</span><br><span class="line">void preorder(node* T, vector&lt;int&gt;&amp; vi) &#123;</span><br><span class="line">	if (T == NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	vi.push_back(T-&gt;val);</span><br><span class="line">	preorder(T-&gt;lchild, vi);</span><br><span class="line">	preorder(T-&gt;rchild, vi);</span><br><span class="line">&#125;</span><br><span class="line">//得到前序镜像二叉树遍历结果</span><br><span class="line">void pre_mirror(node* T, vector&lt;int&gt;&amp; vi) &#123;</span><br><span class="line">	if (T == NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	vi.push_back(T-&gt;val);</span><br><span class="line">	pre_mirror(T-&gt;rchild, vi);</span><br><span class="line">	pre_mirror(T-&gt;lchild, vi);</span><br><span class="line">&#125;</span><br><span class="line">//得到后序二叉树</span><br><span class="line">void postorder(node* T, vector&lt;int&gt;&amp; vi) &#123;</span><br><span class="line">	if (T == NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	postorder(T-&gt;lchild, vi);</span><br><span class="line">	postorder(T-&gt;rchild, vi);</span><br><span class="line">	vi.push_back(T-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">//得到后序镜像二叉树遍历结果</span><br><span class="line">void post_mirror(node* T, vector&lt;int&gt;&amp; vi) &#123;</span><br><span class="line">	if (T == NULL) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	post_mirror(T-&gt;rchild, vi);</span><br><span class="line">	post_mirror(T-&gt;lchild, vi);</span><br><span class="line">	vi.push_back(T-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; initial, pre, pre_m, post, post_m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">	cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">	cout.tie(0);</span><br><span class="line"></span><br><span class="line">	int n, data;</span><br><span class="line">	node* T = NULL;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; data;</span><br><span class="line">		initial.push_back(data);</span><br><span class="line">		build(T, data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preorder(T, pre);</span><br><span class="line">	pre_mirror(T, pre_m);</span><br><span class="line">	postorder(T, post);</span><br><span class="line">	post_mirror(T,post_m);</span><br><span class="line"></span><br><span class="line">	if (initial == pre) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">		for (int i = 0; i &lt; post.size(); i++) &#123;</span><br><span class="line">			if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125;</span><br><span class="line">			cout &lt;&lt; post[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (initial == pre_m) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">		for (int i = 0; i &lt; post_m.size(); i++) &#123;</span><br><span class="line">			if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125;</span><br><span class="line">			cout &lt;&lt; post_m[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-是否同一棵二叉搜索树"><a href="#7-3-是否同一棵二叉搜索树" class="headerlink" title="7-3 是否同一棵二叉搜索树"></a>7-3 是否同一棵二叉搜索树</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">// 定义树节点的结构体</span><br><span class="line">typedef struct TreeNode &#123;</span><br><span class="line">    int val; // 节点的值</span><br><span class="line">    TreeNode* lchild, *rchild; // 左右子节点指针</span><br><span class="line">    int flag; // 标记节点是否被访问过</span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode* newNode(int v); // 创建新节点并初始化</span><br><span class="line">TreeNode* insert(TreeNode* T, int v); // 在树中插入新值</span><br><span class="line">TreeNode* buildTree(int N); // 根据输入构建树</span><br><span class="line">bool check(TreeNode* T, int v); // 检查值是否在树中</span><br><span class="line">bool judge(TreeNode* T, int N); // 判断给定序列是否在树中</span><br><span class="line">void freeTree(TreeNode* T); // 释放树的内存</span><br><span class="line">void reSet(TreeNode* T); // 重置树的标记</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int N, L; // N为树节点个数，L为查询序列长度</span><br><span class="line">    TreeNode* T; // 树的根节点</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; N; // 输入节点个数</span><br><span class="line">    while (N) &#123;</span><br><span class="line">        cin &gt;&gt; L; // 输入查询序列的长度</span><br><span class="line">        T = buildTree(N); // 构建树</span><br><span class="line">        for (int i = 0; i &lt; L; i++) &#123;</span><br><span class="line">            if (judge(T, N)) &#123; // 判断查询序列是否在树中</span><br><span class="line">                cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; // 存在</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; // 不存在</span><br><span class="line">            &#125;</span><br><span class="line">            reSet(T); // 重置树的标记</span><br><span class="line">        &#125;</span><br><span class="line">        freeTree(T); // 释放树的内存</span><br><span class="line">        cin &gt;&gt; N; // 输入下一个节点个数</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建新节点并初始化</span><br><span class="line">TreeNode* newNode(int v) &#123;</span><br><span class="line">    TreeNode* T = new TreeNode;</span><br><span class="line">    T-&gt;flag = 0; // 初始标记为未访问</span><br><span class="line">    T-&gt;val = v; // 设置节点值</span><br><span class="line">    T-&gt;lchild = T-&gt;rchild = NULL; // 左右子节点指针初始化为NULL</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在树中插入新值</span><br><span class="line">TreeNode* insert(TreeNode* T, int v) &#123;</span><br><span class="line">    if (!T) &#123;</span><br><span class="line">        T = newNode(v); // 如果树为空，创建新节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (v &gt; T-&gt;val) &#123;</span><br><span class="line">            T-&gt;rchild = insert(T-&gt;rchild, v); // 插入右子树</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            T-&gt;lchild = insert(T-&gt;lchild, v); // 插入左子树</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return T; // 返回树的根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据输入构建树</span><br><span class="line">TreeNode* buildTree(int N) &#123;</span><br><span class="line">    TreeNode* T;</span><br><span class="line">    int v;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; v; // 读入第一个值</span><br><span class="line">    T = newNode(v); // 创建根节点</span><br><span class="line">    for (int i = 1; i &lt; N; i++) &#123; // 读入剩余值并插入树中</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">        T = insert(T, v);</span><br><span class="line">    &#125;</span><br><span class="line">    return T; // 返回树的根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查值是否在树中</span><br><span class="line">bool check(TreeNode* T, int v) &#123;</span><br><span class="line">    if (T-&gt;flag) &#123; // 如果节点已经被访问过</span><br><span class="line">        if (v &lt; T-&gt;val) &#123; </span><br><span class="line">            return check(T-&gt;lchild, v); // 检查左子树</span><br><span class="line">        &#125; else if (v &gt; T-&gt;val) &#123;</span><br><span class="line">            return check(T-&gt;rchild, v); // 检查右子树</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false; // 值已存在，不允许重复访问</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // 如果节点未被访问</span><br><span class="line">        if (v == T-&gt;val) &#123;</span><br><span class="line">            T-&gt;flag = 1; // 标记为已访问</span><br><span class="line">            return true; // 找到值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false; // 值不匹配</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断给定序列是否在树中</span><br><span class="line">bool judge(TreeNode* T, int N) &#123;</span><br><span class="line">    int v, flag = 0; // flag用于标记序列是否存在</span><br><span class="line">    cin &gt;&gt; v; // 读入第一个值</span><br><span class="line">    if (v == T-&gt;val) &#123;</span><br><span class="line">        T-&gt;flag = 1; // 如果匹配，标记为已访问</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        flag = 1; // 不匹配，设置标志</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; N; i++) &#123; // 继续检查剩余值</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">        if ((!flag) &amp;&amp; (!check(T, v))) &#123; // 如果尚未发现不匹配并且当前值不在树中</span><br><span class="line">            flag = 1; // 设置标志为不匹配</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag ? false : true; // 返回是否完全匹配</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放树的内存</span><br><span class="line">void freeTree(TreeNode* T) &#123;</span><br><span class="line">    if (T-&gt;lchild) &#123; freeTree(T-&gt;lchild); &#125; // 递归释放左子树</span><br><span class="line">    if (T-&gt;rchild) &#123; freeTree(T-&gt;rchild); &#125; // 递归释放右子树</span><br><span class="line">    free(T); // 释放当前节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重置树的标记</span><br><span class="line">void reSet(TreeNode* T) &#123;</span><br><span class="line">    if (T-&gt;lchild) &#123; reSet(T-&gt;lchild); &#125; // 递归重置左子树</span><br><span class="line">    if (T-&gt;rchild) &#123; reSet(T-&gt;rchild); &#125; // 递归重置右子树</span><br><span class="line">    T-&gt;flag = 0; // 重置当前节点标记</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>笛卡尔树</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/</url>
    <content><![CDATA[<p>笛卡尔树是一种特殊的二叉树，其结点包含两个关键字K1和K2。首先笛卡尔树是关于K1的二叉搜索树，即结点左子树的所有K1值都比该结点的K1值小，右子树则大。其次所有结点的K2关键字满足优先队列（不妨设为最小堆）的顺序要求，即该结点的K2值比其子树中所有结点的K2值小。给定一棵二叉树，请判断该树是否笛卡尔树。</p>
<p>输入格式:<br>输入首先给出正整数N（≤1000），为树中结点的个数。随后N行，每行给出一个结点的信息，包括：结点的K1值、K2值、左孩子结点编号、右孩子结点编号。设结点从0~(N-1)顺序编号。若某结点不存在孩子结点，则该位置给出−1。</p>
<p>输出格式:<br>输出YES如果该树是一棵笛卡尔树；否则输出NO。</p>
<h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">27</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">9</span> <span class="number">40</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">12</span> <span class="number">21</span> <span class="number">-1</span> <span class="number">4</span></span><br><span class="line"><span class="number">15</span> <span class="number">22</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">5</span> <span class="number">35</span> <span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>
<h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">27</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">9</span> <span class="number">40</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">12</span> <span class="number">11</span> <span class="number">-1</span> <span class="number">4</span></span><br><span class="line"><span class="number">15</span> <span class="number">22</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">50</span> <span class="number">35</span> <span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k1, k2;</span><br><span class="line">	<span class="type">int</span> left, right;</span><br><span class="line">&#125; node[<span class="number">1010</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> vis[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BST</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node[root].left != <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">BST</span>(node[root].left);</span><br><span class="line">	t.<span class="built_in">push_back</span>(node[root].k1);</span><br><span class="line">	<span class="keyword">if</span> (node[root].right != <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">BST</span>(node[root].right);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBST</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">BST</span>(root);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (t[i] &gt; t[i + <span class="number">1</span>])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isMinHeap</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (node[root].left != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node[node[root].left].k2 &lt; node[root].k2)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isMinHeap</span>(node[root].left))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (node[root].right != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node[node[root].right].k2 &lt; node[root].k2)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isMinHeap</span>(node[root].right))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; node[i].k1 &gt;&gt; node[i].k2 &gt;&gt; node[i].left &gt;&gt; node[i].right;</span><br><span class="line">		<span class="keyword">if</span> (node[i].left != <span class="number">-1</span>)</span><br><span class="line">			vis[node[i].left] = <span class="number">1</span>;<span class="comment">//非根节点置1</span></span><br><span class="line">		<span class="keyword">if</span> (node[i].right != <span class="number">-1</span>)</span><br><span class="line">			vis[node[i].right] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">if</span> (vis[i] == <span class="number">0</span>)</span><br><span class="line">			root = i;<span class="comment">//找到根节点编号</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isBST</span>(root) &amp;&amp; <span class="built_in">isMinHeap</span>(root))</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="7-1-字符串关键字的散列映射"><a href="#7-1-字符串关键字的散列映射" class="headerlink" title="7-1 字符串关键字的散列映射"></a>7-1 字符串关键字的散列映射</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">int getHkey(string s, int m);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">	cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">	cout.tie(0);</span><br><span class="line">	</span><br><span class="line">	int N, P, num;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; P;</span><br><span class="line">	int Hash[P];</span><br><span class="line">	memset(Hash, -1, sizeof(Hash));</span><br><span class="line">	map&lt;string, int&gt; m;</span><br><span class="line">	</span><br><span class="line">	for(int i =0; i &lt; N; i++)&#123;</span><br><span class="line">		if(i)&#123;</span><br><span class="line">			cout &lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		if(m.count(s) == 1)&#123;</span><br><span class="line">			cout &lt;&lt; m[s];</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		num = getHkey(s, P);//得到H（Key） </span><br><span class="line">		int k = 1, temp = num;</span><br><span class="line">		</span><br><span class="line">		//</span><br><span class="line">		while(Hash[temp] != -1)&#123;</span><br><span class="line">			temp = num;</span><br><span class="line">			if(k % 2)&#123;//奇数为正</span><br><span class="line">			    temp = (temp + (int)pow((k + 1) /2, 2)) % P;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				temp = (temp - (int)pow((k + 1) /2, 2) + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		Hash[temp] = 1;</span><br><span class="line">		m[s] = temp;</span><br><span class="line">		cout &lt;&lt; temp;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getHkey(string s, int m)&#123;</span><br><span class="line">	reverse(s.begin(), s.end());</span><br><span class="line">	int p = 0, sum = 0;</span><br><span class="line">	for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">		sum += (s[i] - &#x27;A&#x27;) * pow(32, p);</span><br><span class="line">		p++;</span><br><span class="line">		if(p == 3)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum % m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-集合的模拟实现（类模板）"><a href="#7-2-集合的模拟实现（类模板）" class="headerlink" title="7-2 集合的模拟实现（类模板）"></a>7-2 集合的模拟实现（类模板）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class MySet &#123;</span><br><span class="line">public:</span><br><span class="line">	MySet() &#123; count = 0; &#125;</span><br><span class="line">	int simple_find(T elem);</span><br><span class="line">	void addSet(T elem);</span><br><span class="line">	void delSet(T elem);</span><br><span class="line">	void findElem(T elem);</span><br><span class="line">private:</span><br><span class="line">	T data[100];//用数组来存放所有的集合元素，最多不超过100个元素</span><br><span class="line">	int count;//表示目前集合中有多少个元素</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类外成员函数实现 </span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int MySet&lt;T&gt;::simple_find(T elem) &#123;</span><br><span class="line">	for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">		if (data[i] == elem) &#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void MySet&lt;T&gt;::addSet(T elem) &#123;</span><br><span class="line">	if (this-&gt;count &gt;= 100) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Full Set.&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (simple_find(elem) == -1) &#123;</span><br><span class="line">			cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">			data[count++] = elem;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; elem &lt;&lt; &quot; is already exist!&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void MySet&lt;T&gt;::delSet(T elem) &#123;</span><br><span class="line">	int pos = simple_find(elem);</span><br><span class="line">	if (pos == -1) &#123;</span><br><span class="line">		cout &lt;&lt; elem &lt;&lt; &quot; is not exist!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">		for (int i = pos; i &lt; count - 1; i++) &#123;</span><br><span class="line">			data[i] = data[i + 1];</span><br><span class="line">		&#125;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void MySet&lt;T&gt;::findElem(T elem) &#123;</span><br><span class="line">	int x = simple_find(elem);</span><br><span class="line">	if (x == -1) &#123;</span><br><span class="line">		cout &lt;&lt; elem &lt;&lt; &quot; is not exist!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">	cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">	cout.tie(0);</span><br><span class="line"></span><br><span class="line">	MySet&lt;int&gt; inSet;</span><br><span class="line">	MySet&lt;double&gt; douSet;</span><br><span class="line">	MySet&lt;string&gt; strSet;</span><br><span class="line"></span><br><span class="line">	int type;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		cin &gt;&gt; type;</span><br><span class="line">		if (type == 0) break;</span><br><span class="line"></span><br><span class="line">		if (type == 1) &#123;</span><br><span class="line">			int ops, x;</span><br><span class="line">			cin &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">			switch (ops) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				inSet.addSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				inSet.delSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				inSet.findElem(x);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (type == 2) &#123;</span><br><span class="line">			int ops;</span><br><span class="line">			double x;</span><br><span class="line">			cin &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">			switch (ops) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				douSet.addSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				douSet.delSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				douSet.findElem(x);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (type == 3) &#123;</span><br><span class="line">			int ops;</span><br><span class="line">			string x;</span><br><span class="line">			cin &gt;&gt; ops &gt;&gt; x;</span><br><span class="line">			switch (ops) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				strSet.addSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				strSet.delSet(x);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				strSet.findElem(x);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-集合相似度"><a href="#7-3-集合相似度" class="headerlink" title="7-3 集合相似度"></a>7-3 集合相似度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; s[51];</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int k = 1;</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        while (m--) &#123;</span><br><span class="line">            int x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            s[k].insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        int d = s[a].size() + s[b].size();</span><br><span class="line">        for (auto it: s[a]) &#123;</span><br><span class="line">            if (s[b].find(it) != s[b].end()) &#123; count++;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        double p = count * 100.0 / (d - count);//d - count为两个集合的交集</span><br><span class="line">        printf(&quot;%.2f%\n&quot;, p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-构造散列表"><a href="#7-4-构造散列表" class="headerlink" title="7-4 构造散列表"></a>7-4 构造散列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int a1[18], a2[18];</span><br><span class="line">    for (int i = 0; i &lt; 18; i++) &#123; a1[i] = 0; &#125;</span><br><span class="line">    int n, num, temp;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        a2[i] = num;</span><br><span class="line">        temp = num % 17;// 计算 num 的哈希值（模 17）</span><br><span class="line"></span><br><span class="line">        // 哈希冲突</span><br><span class="line">        // 采用线性探测法（每次偏移 5）寻找下一个空位</span><br><span class="line">        while (a1[temp] != 0) &#123;</span><br><span class="line">            temp = (temp + 5) % 18;</span><br><span class="line">        &#125;</span><br><span class="line">        a1[temp] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 18; j++) &#123;</span><br><span class="line">            if (a1[j] != 0 &amp;&amp; a1[j] == a2[i]) &#123;</span><br><span class="line">                cout &lt;&lt; a2[i] &lt;&lt; &quot; pos: &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-整型关键字的平方探测法散列"><a href="#7-5-整型关键字的平方探测法散列" class="headerlink" title="7-5 整型关键字的平方探测法散列"></a>7-5 整型关键字的平方探测法散列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f; // 定义一个无穷大的常量，用于表示不可达的值</span><br><span class="line"></span><br><span class="line">bool isPrime(long n) &#123;</span><br><span class="line">    if (n &lt; 2) &#123; return false; &#125;</span><br><span class="line">    for (long i = 2; i * i &lt;= n; i++) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false); // 关闭同步，提升输入输出性能</span><br><span class="line">    cin.tie(0); // 解绑 cin 和 cout，避免不必要的刷新</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    int m, n;</span><br><span class="line">    int s, p, v[10007] = &#123; 0 &#125;;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    while (!isPrime(m)) &#123; m++; &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        p = -1;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            //二次探测法查找空位</span><br><span class="line">            if (!v[(s + j * j) % m]) &#123;</span><br><span class="line">                v[(s + j * j) % m] = 1;</span><br><span class="line">                p = (s + j * j) % m;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //输出结果</span><br><span class="line">        if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125;//如果不是第一个输出，先输出空格</span><br><span class="line">        if (p == -1) &#123; cout &lt;&lt; &quot;-&quot;; &#125;</span><br><span class="line">        else &#123; cout &lt;&lt; p; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2024/12/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="7-1-银行业务队列简单模拟"><a href="#7-1-银行业务队列简单模拟" class="headerlink" title="7-1 银行业务队列简单模拟"></a>7-1 银行业务队列简单模拟</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N; <span class="comment">// 读取顾客总数</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; A, B; <span class="comment">// A窗口和B窗口的队列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result; <span class="comment">// 存储结果的向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取顾客编号，并分配到不同的窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> customer;</span><br><span class="line">        cin &gt;&gt; customer;</span><br><span class="line">        <span class="keyword">if</span> (customer % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            A.<span class="built_in">push</span>(customer); <span class="comment">// 奇数顾客到A窗口</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.<span class="built_in">push</span>(customer); <span class="comment">// 偶数顾客到B窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟处理顾客</span></span><br><span class="line">    <span class="keyword">while</span> (!A.<span class="built_in">empty</span>() || !B.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 处理A窗口的顾客</span></span><br><span class="line">        <span class="keyword">if</span> (!A.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(A.<span class="built_in">front</span>()); <span class="comment">// 处理一个A窗口的顾客</span></span><br><span class="line">            A.<span class="built_in">pop</span>(); <span class="comment">// 移除已处理的顾客</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理A窗口的第二个顾客（如果有）</span></span><br><span class="line">        <span class="keyword">if</span> (!A.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(A.<span class="built_in">front</span>());</span><br><span class="line">            A.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理B窗口的顾客</span></span><br><span class="line">        <span class="keyword">if</span> (!B.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(B.<span class="built_in">front</span>()); <span class="comment">// 处理一个B窗口的顾客</span></span><br><span class="line">            B.<span class="built_in">pop</span>(); <span class="comment">// 移除已处理的顾客</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; result[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; result.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 在数字之间输出空格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">// 输出换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-2-Windows消息队列"><a href="#7-2-Windows消息队列" class="headerlink" title="7-2 Windows消息队列"></a>7-2 Windows消息队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">char</span> message[<span class="number">11</span>];</span><br><span class="line">	<span class="type">int</span> rank;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node a, node b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.rank &gt; b.rank;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;<span class="comment">//有序队列，按数字进行从大到小排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string op;</span><br><span class="line">	node p;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; p.message &gt;&gt; p.rank;</span><br><span class="line">			q.<span class="built_in">push</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				cout &lt;&lt; q.<span class="built_in">top</span>().message &lt;&lt; endl;</span><br><span class="line">				q.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;EMPTY QUEUE!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-银行排队问题之单队列多窗口服务"><a href="#7-3-银行排队问题之单队列多窗口服务" class="headerlink" title="7-3 银行排队问题之单队列多窗口服务"></a>7-3 银行排队问题之单队列多窗口服务</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">customer</span>&#123; <span class="comment">// 定义顾客结构体</span></span><br><span class="line">    <span class="type">int</span> T, P;</span><br><span class="line">&#125; customer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    customer cus[<span class="number">1010</span>];</span><br><span class="line">    <span class="type">int</span> i, N, K;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> done_time[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;, done_num[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 初始化每个窗口的完成时间和服务顾客数</span></span><br><span class="line">    <span class="type">int</span> wait_time_all = <span class="number">0</span>, wait_time_max = <span class="number">0</span>, wait_time_one = <span class="number">0</span>;<span class="comment">// 总的等待时间，最长等待时间，单次等待时间</span></span><br><span class="line">    <span class="type">int</span> flag, done_time_min, done_time_max = <span class="number">0</span>, mark;<span class="comment">// 是否需要等待的标记，所有窗口中的最小完成时间和最大完成时间，以及相应窗口的序号</span></span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (rear = <span class="number">0</span>; rear &lt; N; rear++) &#123;</span><br><span class="line">        cin &gt;&gt; cus[rear].T &gt;&gt; cus[rear].P;</span><br><span class="line">        <span class="keyword">if</span> (cus[rear].P &gt; <span class="number">60</span>) &#123; cus[rear].P = <span class="number">60</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>, done_time_min = <span class="number">9999</span>, mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (done_time[i] &lt;= cus[front].T) &#123;<span class="comment">// 队首顾客到达时间在最小完成时间后就不需要等待</span></span><br><span class="line">                done_time[i] = cus[front].T + cus[front].P;<span class="comment">// 新的完成时间为新顾客到达时间+事务处理时间</span></span><br><span class="line">                done_num[i]++;<span class="comment">// 服务顾客数+1</span></span><br><span class="line">                flag = <span class="number">1</span>;<span class="comment">// 置1表示无需等待</span></span><br><span class="line">                front++;<span class="comment">// 队首顾客出队</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不满足前一个条件，即完成时间在顾客到达时间之后，顾客需要等待</span></span><br><span class="line">            <span class="keyword">if</span> (done_time_min &gt; done_time[i]) &#123;</span><br><span class="line">                <span class="comment">// 记录该窗口的完成时间和窗口序号，k次循环后留下的即是最小完成时间和对应窗口序号</span></span><br><span class="line">                done_time_min = done_time[i];</span><br><span class="line">                mark = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;<span class="comment">// flag = 0为需要等待</span></span><br><span class="line">            wait_time_one = done_time_min - cus[front].T;</span><br><span class="line">            <span class="keyword">if</span> (wait_time_max &lt; wait_time_one) &#123;</span><br><span class="line">                wait_time_max = wait_time_one;</span><br><span class="line">            &#125;</span><br><span class="line">            wait_time_all += wait_time_one;</span><br><span class="line">            done_time[mark] = done_time_min + cus[front].P;</span><br><span class="line">            done_num[mark]++;</span><br><span class="line">            front++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (done_time_max &lt; done_time[i]) &#123;</span><br><span class="line">            done_time_max = done_time[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f %d %d\n&quot;</span>, <span class="number">1.0</span> * (wait_time_all / N), wait_time_max, done_time_max);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        cout &lt;&lt; done_num[i];</span><br><span class="line">        <span class="keyword">if</span> (i == K - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-列车调度"><a href="#7-4-列车调度" class="headerlink" title="7-4 列车调度"></a>7-4 列车调度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    v.<span class="built_in">push_back</span>(last);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now &gt; last) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), now) - v.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (pos != v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                k = <span class="number">1</span>;</span><br><span class="line">                v[pos] = now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!k) &#123; v.<span class="built_in">push_back</span>(now); &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), now) - v.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (pos != v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                v[pos] = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = now;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>PTA</tag>
      </tags>
  </entry>
</search>
